# 牛客面试必刷101

## BM1 反转链表

## 描述

给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： 0\leq n\leq10000≤*n*≤1000

要求：空间复杂度 O(1)*O*(1) ，时间复杂度 O(n)*O*(*n*) 。

如当输入链表{1,2,3}时，

经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。

以上转换过程如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249)

## 示例1

输入：

```
{1,2,3}
```

复制

返回值：

```
{3,2,1}
```

复制

## 示例2

输入：

```
{}
```

复制

返回值：

```
{}
```

复制

说明：

```
空链表则输出空
```

### 1，使用栈解决

链表的反转是老生常谈的一个问题了，同时也是面试中常考的一道题。最简单的一种方式就是使用栈，因为栈是先进后出的。实现原理就是把链表节点一个个入栈，当全部入栈完之后再一个个出栈，出栈的时候在把出栈的结点串成一个新的链表。原理如下
![图片说明](https://uploadfiles.nowcoder.com/images/20201221/606614833_1608540878085/DBF638ECACC4AB70D789585871EFDFF3)

代码：

```java
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        Stack<ListNode> stack = new Stack<>();
        // 把链表结点全部摘掉放到栈中
        while(head != null) {
            stack.push(head);
            head = head.next;
        }
        if(stack.isEmpty()) {
            return null;
        }
        ListNode node = stack.pop();
        ListNode dummy = node;
        // 栈中的结点全部出栈，然后重新连成一个新的链表
        while(!stack.isEmpty()) {
            ListNode tempNode = stack.pop();
            node.next = tempNode;
            node = node.next;
        }
        // 最后一个结点就是反转前的头节点，一定要让它的next等于空，
        // 否则会构成环
        node.next = null;
        return dummy;
    }
}
```

### 2,双链表求解

双链表求解是把原链表的结点一个个摘掉，每次摘掉的链表都让他成为新的链表的头结点，然后更新新链表。下面以链表1→2→3→4为例画个图来看下。
![图片说明](https://uploadfiles.nowcoder.com/images/20201221/606614833_1608540924664/6B7B002EA5774E94CC51CBCB0EC7B06C)

![图片说明](https://uploadfiles.nowcoder.com/images/20201221/606614833_1608540933709/9F0348C9DC1A70ED7D678E4F4C56E04C)
他每次访问的原链表节点都会成为新链表的头结点，最后再来看下代码

```java
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        // 新链表
        ListNode newHead = null;
        while(head != null) {
            // 先保存访问的节点的下一个节点，
            // 保存起来，留着下一步访问的
            ListNode temp = head.next;
            // 每次访问的原链表节点都会成为新链表的头节点
            // 其实就是把新链表挂到访问的原链表节点的
            head.next = newHead;
            // 更新新链表
            newHead = head;
            // 重新赋值，继续访问
            head = temp;
        }
        // 返回新链表
        return newHead;
    }
}
```

