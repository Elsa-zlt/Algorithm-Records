

# 牛客面试必刷101

# BM1 反转链表

## 描述

给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： 0\leq n\leq10000≤*n*≤1000

要求：空间复杂度 O(1)*O*(1) ，时间复杂度 O(n)*O*(*n*) 。

如当输入链表{1,2,3}时，

经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。

以上转换过程如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249)

## 示例1

输入：

```
{1,2,3}
```

复制

返回值：

```
{3,2,1}
```

复制

## 示例2

输入：

```
{}
```

复制

返回值：

```
{}
```

复制

说明：

```
空链表则输出空
```

### 1,使用栈解决

链表的反转是老生常谈的一个问题了，同时也是面试中常考的一道题。最简单的一种方式就是使用栈，因为栈是先进后出的。实现原理就是把链表节点一个个入栈，当全部入栈完之后再一个个出栈，出栈的时候在把出栈的结点串成一个新的链表。原理如下
![图片说明](https://uploadfiles.nowcoder.com/images/20201221/606614833_1608540878085/DBF638ECACC4AB70D789585871EFDFF3)

代码：

```java
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        Stack<ListNode> stack = new Stack<>();
        // 把链表结点全部摘掉放到栈中
        while(head != null) {
            stack.push(head);
            head = head.next;
        }
        if(stack.isEmpty()) {
            return null;
        }
        ListNode node = stack.pop();
        ListNode dummy = node;
        // 栈中的结点全部出栈，然后重新连成一个新的链表
        while(!stack.isEmpty()) {
            ListNode tempNode = stack.pop();
            node.next = tempNode;
            node = node.next;
        }
        // 最后一个结点就是反转前的头节点，一定要让它的next等于空，
        // 否则会构成环
        node.next = null;
        return dummy;
    }
}
```

### 2,双链表求解

双链表求解是把原链表的结点一个个摘掉，每次摘掉的链表都让他成为新的链表的头结点，然后更新新链表。下面以链表1→2→3→4为例画个图来看下。
![图片说明](https://uploadfiles.nowcoder.com/images/20201221/606614833_1608540924664/6B7B002EA5774E94CC51CBCB0EC7B06C)

![图片说明](https://uploadfiles.nowcoder.com/images/20201221/606614833_1608540933709/9F0348C9DC1A70ED7D678E4F4C56E04C)
他每次访问的原链表节点都会成为新链表的头结点，最后再来看下代码

```java
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        // 新链表
        ListNode newHead = null;
        while(head != null) {
            // 先保存访问的节点的下一个节点，
            // 保存起来，留着下一步访问的
            ListNode temp = head.next;
            // 每次访问的原链表节点都会成为新链表的头节点
            // 其实就是把新链表挂到访问的原链表节点的
            head.next = newHead;
            // 更新新链表
            newHead = head;
            // 重新赋值，继续访问
            head = temp;
        }
        // 返回新链表
        return newHead;
    }
}
```

### 3,递归解决

我们再来回顾一下递归的模板，终止条件，递归调用，逻辑处理。

```java
public ListNode reverseList(参数0) {
    if (终止条件)
        return;

    逻辑处理（可能有，也可能没有，具体问题具体分析）

    //递归调用
    ListNode reverse = reverseList(参数1);

    逻辑处理（可能有，也可能没有，具体问题具体分析）
}
```

终止条件就是链表为空，或者是链表没有尾结点的时候，直接返回

```java
if (head == null || head.next == null)
    return head;
```

递归调用是要从当前节点的下一个结点开始递归。逻辑处理这块是要把当前节点挂到递归之后的链表的末尾，看下代码

```java
public ListNode ReverseList(ListNode head) {
    //终止条件
    if (head == null || head.next == null)
        return head;
    //保存当前节点的下一个结点
    ListNode next = head.next;
    //从当前节点的下一个结点开始递归调用
    ListNode reverse = ReverseList(next);
    //reverse是反转之后的链表，因为函数reverseList
    // 表示的是对链表的反转，所以反转完之后next肯定
    // 是链表reverse的尾结点，然后我们再把当前节点
    //head挂到next节点的后面就完成了链表的反转。
    next.next = head;
    //这里head相当于变成了尾结点，尾结点都是为空的，
    //否则会构成环
    head.next = null;
    return reverse;
}
```

因为递归调用之后head.next节点就会成为reverse节点的尾结点，我们可以直接让head.next.next = head;，这样代码会更简洁一些，看下代码

```java
public ListNode ReverseList(ListNode head) {
    if (head == null || head.next == null)
        return head;
    ListNode reverse = ReverseList(head.next);
    head.next.next = head;
    head.next = null;
    return reverse;
}
```

这种递归往下传递的时候基本上没有逻辑处理，当往回反弹的时候才开始处理，也就是从链表的尾端往前开始处理的。我们还可以再来改一下，在链表递归的时候从前往后处理，处理完之后直接返回递归的结果，这就是所谓的尾递归，这种运行效率要比上一种好很多

```java
public ListNode ReverseList(ListNode head) {
    return reverseListInt(head, null);
}

private ListNode reverseListInt(ListNode head, ListNode newHead) {
    if (head == null)
        return newHead;
    ListNode next = head.next;
    head.next = newHead;
    return reverseListInt(next, head);
}
```

尾递归虽然也会不停的压栈，但由于最后返回的是递归函数的值，所以在返回的时候都会一次性出栈，不会一个个出栈这么慢。但如果我们再来改一下，像下面代码这样又会一个个出栈了

```java
public ListNode ReverseList(ListNode head) {
    return reverseListInt(head, null);
}

private ListNode reverseListInt(ListNode head, ListNode newHead) {
    if (head == null)
        return newHead;
    ListNode next = head.next;
    head.next = newHead;
    ListNode node = reverseListInt(next, head);
    return node;
}
```

# **BM2** **链表内指定区间反转**

## 描述

将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)*O*(*n*)，空间复杂度 O(1)*O*(1)。
例如：
给出的链表为 1\to 2 \to 3 \to 4 \to 5 \to NULL1→2→3→4→5→*N**U**L**L*, m=2,n=4*m*=2,*n*=4,
返回 1\to 4\to 3\to 2\to 5\to NULL1→4→3→2→5→*N**U**L**L*.



数据范围： 链表长度 0 < size \le 10000<*s**i**z**e*≤1000，0 < m \le n \le size0<*m*≤*n*≤*s**i**z**e*，链表中每个节点的值满足 |val| \le 1000∣*v**a**l*∣≤1000

要求：时间复杂度 O(n)*O*(*n*) ，空间复杂度 O(n)*O*(*n*)

进阶：时间复杂度 O(n)*O*(*n*)，空间复杂度 O(1)*O*(1)

## 示例1

输入：

```
{1,2,3,4,5},2,4
```

返回值：

```
{1,4,3,2,5}
```

## 示例2

输入：

```
{5},1,1
```

返回值：

```
{5}
```

### 解法一：双指针(两次遍历)

#### 思路步骤：

- 要反转局部链表，可以将该局部部分当作完整链表进行反转
- 再将已经反转好的局部链表与其他节点建立连接，重构链表
- 建议使用虚拟头节点的技巧，可以避免对头节点复杂的分类考虑，简化操作。
- 反转前后图示：
  ![图片说明](https://uploadfiles.nowcoder.com/images/20210711/583846419_1625990408507/FDC7A345EC7E54A1D8FFC23AF976598B)
- 配图说明：
  ![图片说明](https://uploadfiles.nowcoder.com/images/20210711/583846419_1625990532576/D255754A19C09A1F9220E53949CB74F3)
- 反转步骤：
  ![图片说明](https://uploadfiles.nowcoder.com/images/20210711/583846419_1625990556079/EF085794A4038C45808F0F12B7E3C219)

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 
     * @param m int整型 
     * @param n int整型 
     * @return ListNode类
     */
       // 解法一：双指针(两次遍历)
       //说明：方便理解，以下注释中将用left，right分别代替m,n节点 

    public ListNode reverseBetween (ListNode head, int m, int n) {
             //设置虚拟头节点
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;

        ListNode pre = dummyNode;
        //1.走left-1步到left的前一个节点
        for(int i=0;i<m-1;i++){
            pre = pre.next;
        }

        //2.走roght-left+1步到right节点
        ListNode rigthNode = pre;
        for(int i=0;i<n-m+1;i++){
            rigthNode = rigthNode.next;
        }

        //3.截取出一个子链表
        ListNode leftNode = pre.next;
        ListNode cur = rigthNode.next;

        //4.切断链接
        pre.next=null;
        rigthNode.next=null;

        //5.反转局部链表
        reverseLinkedList(leftNode);

        //6.接回原来的链表
        pre.next = rigthNode;
        leftNode.next = cur;
        return dummyNode.next;
    }
    //反转局部链表
    private void reverseLinkedList(ListNode head){
        ListNode pre = null;
        ListNode cur = head;
        while(cur!=null){
            //Cur_next 指向cur节点的下一个节点
            ListNode Cur_next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = Cur_next ;
        }
    }
}
```

### 解法二：一次遍历（对解法一的优化）

- 解法一一个明显不足在于，当所给子区间[m,n]范围过大，恰好等于链表头尾节点是，遍历成本变大。
- 解法二的思路在于，固定子区间外的节点。
- 在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。
  - `curr`：指向待反转区域的第一个节点 left；
  - `Cur_next`：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 Cur_next 会变化；
  - `pre`：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。
- 实现流程以及步骤：
  ![图片说明](https://uploadfiles.nowcoder.com/images/20210711/583846419_1625990485165/7BB5BF1ECAE4CE6E18583D9D299A3924)

### Java参考代码：

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 
     * @param m int整型 
     * @param n int整型 
     * @return ListNode类
     */
    public ListNode reverseBetween (ListNode head, int m, int n) {
        // 设置虚拟节点
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;
        ListNode pre = dummyNode;
        for(int i = 0; i < m - 1; i++) {
            pre = pre.next;
        }
 
        ListNode cur = pre.next;
        ListNode Cur_next ;
        for(int i = 0; i < n - m; i++) {
            Cur_next = cur.next;
            cur.next = Cur_next.next;
            Cur_next .next = pre.next;
            pre.next = Cur_next ;
        }
        return dummyNode.next;
    }
}
```

# **BM3** **链表中的节点每k个一组翻转**

## 描述

将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表
如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样
你不能更改节点中的值，只能更改节点本身。

数据范围： \ 0 \le n \le 2000 0≤*n*≤2000 ， 1 \le k \le 20001≤*k*≤2000 ，链表中每个元素都满足 0 \le val \le 10000≤*v**a**l*≤1000
要求空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

例如：

给定的链表是 1\to2\to3\to4\to51→2→3→4→5

对于 k = 2*k*=2 , 你应该返回 2\to 1\to 4\to 3\to 52→1→4→3→5

对于 k = 3*k*=3 , 你应该返回 3\to2 \to1 \to 4\to 53→2→1→4→5

## 示例1

输入：

```
{1,2,3,4,5},2
```

返回值：

```
{2,1,4,3,5}
```

## 示例2

输入：

```
{},1
```

返回值：

```
{}
```

### 方法一 模拟法

将一条链表分块分为链表长度/k块链表，如果处不尽则说明后面会有剩下的那一块是不满长度为k的。在最初的时候需要定义两个NodeList表示result(结果)和 now(当前所到达的结果链表的位置)。之后遍历块的长度，对每一个链表块进行翻转，再翻转完后将完成的链表插入到now链表的下一个，再将now链表更新到最前即可。
![图片说明](https://uploadfiles.nowcoder.com/images/20210710/367063030_1625908107370/129E2F1EE969730B8F8C6A1BFE3AE7BD)

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    public ListNode reverseKGroup (ListNode head, int k) {
        if(k <= 1) {
            return head;
        }
        if(head == null) {
            return head;
        }
        ListNode node = head;
        int len = length(head);
        head = node;
        // 分成sx块向下取整
        int sx = len / k;
        ListNode res = new ListNode(0);
        ListNode now = res;
        int cnt = 0;
        for(int i = 0; i < sx; i++) {
            ListNode tmp = null;
            // 将第i块的元素翻转
            for(int j = 0; j < k; j++) {
                ListNode b1 = head.next;
                head.next = tmp;
                tmp = head;
                head = b1;
            }
            now.next = tmp;
            // 将now更新到最前的一个点
            while(now.next != null) {
                now = now.next;
            }
        }
        now.next = head;
        return res.next;
    }
    
    // 获取链表长度
    public int length(ListNode now) {
        int cnt = 0;
        if(now != null) {
            cnt = 1;
        }
        while(now.next != null) {
            cnt++;
            now = now.next;
        }
        return cnt;
    }
}
```

### 方法二 栈

和方法一一样将链表分成每段长度为k的子链表，将每个链表存入栈中，当栈中有k个元素即可一一取出，之后按取出的顺序重组链表就是这一段中翻转的链表，要注意的是处理尾部不满长度为k的链表块时直接取栈底的元素做为最后一段即可。
![图片说明](https://uploadfiles.nowcoder.com/images/20210710/367063030_1625910139111/250431532A1E8337BA36A6DA24234693)

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    public ListNode reverseKGroup (ListNode head, int k) {
        if(k <= 1 || head == null) {
            return head;
        }
        // 模拟栈
        Deque<ListNode> st = new ArrayDeque<ListNode>();
        ListNode res = new ListNode(0);
        ListNode now = res;
        int cnt = 0;
        while(true) {
            // 将当前链表的前k个存入栈中
            for(int i = 0; i < k; i++) {
                st.push(head);
                head = head.next;
                cnt++;
                if(head == null) {
                    break;
                }
            }
            // 如果当前栈中有k个元素则一一取出存入链表
            if(cnt == k) {
                while(!st.isEmpty()) {
                    now.next = st.pop();
                    now = now.next;
                    now.next = null;
                }
            }
            if(head == null) {
                break;
            }
            cnt = 0;
        }
        ListNode end = null;
        // 如果栈中还有剩下的就说明是最后的一块直接取栈底即可
        while(!st.isEmpty()) {
            end = st.pop();
        }
        now.next = end;
        return res.next;
    }
}
```

# **BM4** **合并两个排序的链表**

## 描述

输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。

数据范围： 0 \le n \le 10000≤*n*≤1000，-1000 \le 节点值 \le 1000−1000≤节点值≤1000
要求：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}，转换过程如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634208575589/09DD8C2662B96CE14928333F055C5580)

或输入{-1,2,4},{1,3,4}时，合并后的链表为{-1,1,2,3,4,4}，所以对应的输出为{-1,1,2,3,4,4}，转换过程如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634208729766/8266E4BFEDA1BD42D8F9794EB4EA0A13)

## 示例1

输入：

```
{1,3,5},{2,4,6}
```

复制

返回值：

```
{1,2,3,4,5,6}
```

## 示例2

输入：

```
{},{}
```

返回值：

```
{}
```

```java
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode dummy = new ListNode(-1);
        ListNode res = dummy;
        // 必须保证两个list都不为空
        while(list1 != null & list2 != null) {
            if(list1.val > list2.val) {
                dummy.next = list2;
                list2 = list2.next;
                dummy = dummy.next;
            } else if(list1.val <= list2.val) {
                dummy.next = list1;
                list1 = list1.next;
                dummy = dummy.next;
            }
        }
        // list1后面还有，就把剩下的全部拿走
        if(list1 != null) {
            dummy.next = list1;
        }
        if(list2 != null) {
            dummy.next = list2;
        }
        return res.next;
    }

}
```

# **BM5** **合并k个已排序的链表**

## 描述

合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。

数据范围：节点总数满足 0 \le n \le 10^50≤*n*≤105，链表个数满足 1 \le k \le 10^5 \1≤*k*≤105 ，每个链表的长度满足 1 \le len \le 200 \1≤*l**e**n*≤200 ，每个节点的值满足 |val| <= 1000∣*v**a**l*∣<=1000

要求：时间复杂度 O(nlogk)*O*(*n**l**o**g**k*)

## 示例1

输入：

```
[{1,2,3},{4,5,6,7}]
```

返回值：

```
{1,2,3,4,5,6,7}
```

```java
import java.util.*;
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    // 合并两个链表函数
    public ListNode Merge(ListNode list1, ListNode list2) {
        // 一个为空，直接返回另外一个
        if(list1 == null) {
            return list2;
        }
        if(list2 == null) {
            return list1;
        }
        // 加一个表头
        ListNode head = new ListNode(0);
        ListNode cur = head;
        // 两个链表都要不为空
        while(list1 != null && list2 != null) {
            // 取较小值的节点
            if(list1.val <= list2.val) {
                cur.next = list1;
                // 只移动取值的指针
                list1 = list1.next;
            } else {
                cur.next = list2;
                // 只移动取值的指针
                list2 = list2.next;
            }
            cur = cur.next;
        }
        // 哪个链表还有剩，直接连在后面
        if(list1 != null) {
            cur.next = list1;
        } else {
            cur.next = list2;
        }
        return head.next;
    }
    
    ListNode divideMerge(ArrayList<ListNode> lists, int left, int right) {
        if(left > right) {
            return null;
        } else if(left == right){ // 中间情况
            return lists.get(left);
        }
        int mid = (left + right) / 2;
        return Merge(divideMerge(lists, left, mid), divideMerge(lists, mid + 1, right));
    }
    
    public ListNode mergeKLists(ArrayList<ListNode> lists) {
        return divideMerge(lists, 0, lists.size() - 1);
    }
}
```

# **BM6** **判断链表中是否有环**

## 描述

判断给定的链表中是否有环。如果有环则返回true，否则返回false。

数据范围：链表长度 0 \le n \le 100000≤*n*≤10000，链表中任意节点的值满足 |val| <= 100000∣*v**a**l*∣<=100000

要求：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

输入分为两部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。

例如输入{3,2,0,-4},1时，对应的链表结构如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20220110/423483716_1641800950920/0710DD5D9C4D4B11A8FA0C06189F9E9C)

可以看出环的入口结点为从头结点开始的第1个结点（注：头结点为第0个结点），所以输出true。

## 示例1

输入：

```
{3,2,0,-4},1
```

复制

返回值：

```
true
```

复制

说明：

```
第一部分{3,2,0,-4}代表一个链表，第二部分的1表示，-4到位置1（注：头结点为位置0），即-4->2存在一个链接，组成传入的head为一个带环的链表，返回true               
```

## 示例2

输入：

```
{1},-1
```

返回值：

```
false
```

说明：

```
第一部分{1}代表一个链表，-1代表无环，组成传入head为一个无环的单链表，返回false               
```

## 示例3

输入：

```
{-1,-7,7,-4,19,6,-9,-5,-2,-5},6
```

返回值：

```
true
```

```java
import java.util.*;
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null) {
            return false;
        }
        ListNode fast = head, slow = head;
        while(fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) {
                return true;
            }
        }
        return false;
    }
}
```

# **BM7** **链表中环的入口结点**

## 描述

给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。

数据范围： n\le10000*n*≤10000，1<=结点值<=100001<=结点值<=10000

要求：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211025/423483716_1635154005498/DA92C945EF643F1143567935F20D6B46)

可以看到环的入口结点的结点值为3，所以返回结点值为3的结点。

### 输入描述：

输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表

### 返回值描述：

返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。

## 示例1

输入：

```
{1,2},{3,4,5}
```

返回值：

```
3
```

说明：

```
返回环形链表入口结点，我们后台程序会打印该环形链表入口结点对应的结点值，即3    
```

```java
import java.util.*;
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    // 判断链表有没有环，返回相遇的地方
    public ListNode hasCycle(ListNode head) {
        // 先判断链表为空的情况
        if(head == null) {
            return null;
        }
        // 快慢指针
        ListNode fast = head;
        ListNode slow = head;
        // 如果没环快指针会先到链表尾
        while(fast != null && fast.next != null) {
            // 快指针移动两步
            fast = fast.next.next;
            // 慢指针移动一步
            slow = slow.next;
            if(fast == slow) {
                return slow;
            }
        }
        // 到末尾说明没有环，返回null
        return null;
    }

    public ListNode EntryNodeOfLoop(ListNode pHead) {
        ListNode slow = hasCycle(pHead);
        // 没有环
        if(slow == null) {
            return slow;
        }
        // 快指针回到表头
        ListNode fast = pHead;
        // 再次相遇即是环入口
        while(fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

# **BM8** **链表中倒数最后k个结点**

例如输入{1,2,3,4,5},2时，对应的链表结构如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084313645/5407F55227804F31F5C5D73558596F2C)

其中蓝色部分为该链表的最后2个结点，所以返回倒数第2个结点（也即结点值为4的结点）即可，系统会打印后面所有的节点来比较。

## 示例1

输入：

```
{1,2,3,4,5},2
```

返回值：

```
{4,5}
```

说明：

```
返回倒数第2个节点4，系统会打印后面所有的节点来比较。 
```

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 *   public ListNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    public ListNode FindKthToTail (ListNode pHead, int k) {
        int n = 0;
        ListNode fast = pHead;
        ListNode slow = pHead;
        // 快指针先行k步
        for(int i = 0; i < k; i++) {
            if(fast != null) {
                fast = fast.next;
            }
            // 达不到k步说明链表过短，没有倒数k
            else {
                return slow = null;
            }
        }
        while(fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

# **BM9** **删除链表的倒数第n个节点**

## 描述

给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针
例如，

给出的链表为: 1\to 2\to 3\to 4\to 51→2→3→4→5, n= 2*n*=2.
删除了链表的倒数第 n*n* 个节点之后,链表变为1\to 2\to 3\to 51→2→3→5.

数据范围： 链表长度 0\le n \le 10000≤*n*≤1000，链表中任意节点的值满足 0 \le val \le 1000≤*v**a**l*≤100

要求：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)
备注：

题目保证 n*n* 一定是有效的

## 示例1

输入：

```
{1,2},2    
```

返回值：

```
{2} 
```

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 
     * @param n int整型 
     * @return ListNode类
     */
    public ListNode removeNthFromEnd (ListNode head, int n) {
        // 添加表头
        ListNode res = new ListNode(-1);
        res.next = head;
        // 当前节点
        ListNode cur = head;
        // 前序节点
        ListNode pre = res;
        ListNode fast = head;
        // 快指针先行n步
        while(n != 0){
            fast = fast.next;
            n--;
        }
        // 快慢指针同步，快指针到达末尾，慢指针就到了倒数第n个位置
        while(fast != null){
            fast = fast.next;
            pre = cur;
            cur = cur.next;
        }
        // 删除该位置的节点
        pre.next = cur.next;
        // 返回去掉头
        return res.next;
    }
}
```

# **BM10** **两个链表的第一个公共结点**

## 描述

输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

数据范围： n \le 1000*n*≤1000
要求：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211104/423483716_1635999204882/394BB7AFD5CEA3DC64D610F62E6647A6)

可以看到它们的第一个公共结点的结点值为6，所以返回结点值为6的结点。

### 输入描述：

输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。

### 返回值描述：

返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。

## 示例1

输入：

```
{1,2,3},{4,5},{6,7}
```

返回值：

```
{6,7}
```

说明：

```
第一个参数{1,2,3}代表是第一个链表非公共部分，第二个参数{4,5}代表是第二个链表非公共部分，最后的{6,7}表示的是2个链表的公共部分
这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共节点的 
```

```java
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        Set<ListNode> set = new HashSet<>();
        while(pHead1 != null) {
            set.add(pHead1);
            pHead1 = pHead1.next;
        }
        while(pHead2 != null && !set.contains(pHead2)) {
            pHead2 = pHead2.next;
        }
        return pHead2;
    }
}
```

# **BM11** **链表相加(二)**

## 描述

假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。

给定两个这种链表，请生成代表两个整数相加值的结果链表。

数据范围：0 \le n,m \le 10000000≤*n*,*m*≤1000000，链表任意值 0 \le val \le 90≤*v**a**l*≤9
要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

例如：链表 1 为 9->3->7，链表 2 为 6->3，最后生成新的结果链表为 1->0->0->0。

![img](https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084743981/C2DB572B01B0FDC03C097BE7ABA45114)

## 示例1

输入：

```
[9,3,7],[6,3]
```

返回值：

```
{1,0,0,0}
```

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
    public ListNode addInList (ListNode head1, ListNode head2) {
        // list1栈
        LinkedList<Integer> list1 = new LinkedList<>();
        // list2栈
        LinkedList<Integer> list2 = new LinkedList<>();
        // 入栈
        putData(list1, head1);
        putData(list2, head2);
        ListNode newNode = null;
        ListNode head = null;
        int carry = 0;
        while(!list1.isEmpty() || !list2.isEmpty() || carry != 0) {
            // 依次从栈中取出
            int x = (list1.isEmpty() ? 0 : list1.pop());
            int y = (list2.isEmpty() ? 0 : list2.pop());
            // 与进位一起相加
            int sum = x + y + carry;
            // 更新进位
            carry = sum / 10;
            // 将计算值放入节点
            newNode = new ListNode(sum % 10);
            newNode.next = head;
            head = newNode;
        }
        return head;
    }
    
    private static void putData(LinkedList<Integer> s1, ListNode head1) {
        if(s1 == null) {
            s1 = new LinkedList<>();
        }
        // 遍历节点将其插入栈中
        while(head1 != null) {
            s1.push(head1.val);
            head1 = head1.next;
        }
    }
}
```

# **BM12** **单链表的排序**

## 描述

给定一个节点数为n的无序单链表，对其按升序排序。

数据范围：0 < n \le 1000000<*n*≤100000

要求：时间复杂度 O(nlogn)*O*(*n**l**o**g**n*)

## 示例1

输入：

```
{1,3,2,4,5}
```

返回值：

```
{1,2,3,4,5}
```

## 示例2

输入：

```
{-1,0,-2}
```

返回值：

```
{-2,-1,0}
```

```java
import java.util.*;
public class Solution {
    public ListNode sortInList (ListNode head) {
        ArrayList<Integer> nums = new ArrayList(); 
        ListNode p = head;
        //遍历链表，将节点值加入数组
        while(p != null){ 
            nums.add(p.val);
            p = p.next;
        }
        p = head;
        //对数组元素排序
        Collections.sort(nums); 
        //遍历数组
        for(int i = 0; i < nums.size(); i++){ 
            //将数组元素依次加入链表
            p.val = nums.get(i); 
            p = p.next;
        }
        return head;
    }
}
```

# **BM13** **判断一个链表是否为回文结构**

## 描述

给定一个链表，请判断该链表是否为回文结构。

回文是指该字符串正序逆序完全一致。

数据范围： 链表节点数 0 \le n \le 10^50≤*n*≤105，链表中每个节点的值满足 |val| \le 10^7∣*v**a**l*∣≤107

## 示例1

输入：

```
{1}
```

返回值：

```
true
```

## 示例2

输入：

```
{2,1}
```

返回值：

```
false
```

说明：

```
2->1      
```

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 the head
     * @return bool布尔型
     */
    public boolean isPail (ListNode head) {
        if(head == null) {
            return false;
        }
        ListNode node = head;
        List<Integer> list = change(head);
        head = node;
        
        return check(list);
    }
    
    public boolean check(List<Integer> list) {
        int len = list.size();
        for(int i = 0; i < len / 2; i++) {
            int i1 = list.get(i);
            int i2 = list.get(len - i - 1);
            if(i1 != i2) {
                return false;
            }
        }
        return true;
    }
    
    public List<Integer> change(ListNode head) {
        List<Integer> list = new ArrayList<>();
        while(head != null) {
            list.add(head.val);
            head = head.next;
        }
        return list;
    }
}
```

# **BM14** **链表的奇偶重排**

## 描述

给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。

注意是节点的编号而非节点的数值。

数据范围：节点数量满足 0 \le n \le 10^50≤*n*≤105，节点中的值都满足 0 \le val \le 10000≤*v**a**l*≤1000

要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
{1,2,3,4,5,6}
```

复制

返回值：

```
{1,3,5,2,4,6}
```

复制

说明：

```
1->2->3->4->5->6->NULL
重排后为1->3->5->2->4->6->NULL
```

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 *   public ListNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
    public ListNode oddEvenList (ListNode head) {
        // 如果链表为空，不用重排
        if(head == null)
            return head;
        // even开头指向第二个节点，可能为空
        ListNode even = head.next;
        // odd开头指向第一个节点
        ListNode odd = head;
        // 指向even开头
        ListNode evenhead = even;
        while(even != null && even.next != null){
            // odd连接even的后一个，即奇数位
            odd.next = even.next;
            // odd进入后一个奇数位
            odd = odd.next;
            // even连接后一个奇数的后一位，即偶数位
            even.next = odd.next;
            // even进入后一个偶数位
            even = even.next;
        }
        // even整体接在odd后面
        odd.next = evenhead;
        return head;
    }
}
```



# **BM15** **删除有序链表中重复的元素-I**

## 描述

删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次
例如：
给出的链表为1\to1\to21→1→2,返回1 \to 21→2.
给出的链表为1\to1\to 2 \to 3 \to 31→1→2→3→3,返回1\to 2 \to 31→2→3.

数据范围：链表长度满足 0 \le n \le 1000≤*n*≤100，链表中任意节点的值满足 |val| \le 100∣*v**a**l*∣≤100

进阶：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
{1,1,2}
```

返回值：

```
{1,2}
```

## 示例2

输入：

```
{}
```

返回值：

```
{}
```

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
    public ListNode deleteDuplicates (ListNode head) {
        // 空链表
        if(head == null) {
            return head;
        }
        // 遍历指针
        ListNode cur = head;
        // 指针当前和下一位不为空
        while(cur != null && cur.next != null) {
            // 如果当前与下一位相等则忽略下一位
            if(cur.val == cur.next.val) {
                cur.next = cur.next.next;
            } else {
                cur = cur.next;
            }
        }
        return head;
    }
}
```

# **BM16** **删除有序链表中重复的元素-II**

## 描述

给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。
例如：
给出的链表为1 \to 2\to 3\to 3\to 4\to 4\to51→2→3→3→4→4→5, 返回1\to 2\to51→2→5.
给出的链表为1\to1 \to 1\to 2 \to 31→1→1→2→3, 返回2\to 32→3.

数据范围：链表长度 0 \le n \le 100000≤*n*≤10000，链表中的值满足 |val| \le 1000∣*v**a**l*∣≤1000

要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

进阶：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
{1,2,2}
```

返回值：

```
{1}
```

```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
    public ListNode deleteDuplicates (ListNode head) {
        // 空链表
        if(head == null) {
            return null;
        }
        // 在链表前加一个表头
        ListNode res = new ListNode(0);
        res.next = head;
        ListNode cur = res;
        while(cur.next != null && cur.next.next != null) {
            // 遇到相邻两个节点值相同
            if(cur.next.val == cur.next.next.val) {
                int temp = cur.next.val;
                // 将所有相同的都跳过
                while(cur.next != null && cur.next.val == temp) {
                    cur.next = cur.next.next;
                }
            } else {
                cur = cur.next;
            }
        }
        // 返回时去掉表头
        return res.next;
    }
}
```

# **BM17** **二分查找-I**

## 描述

请实现无重复数字的升序数组的二分查找

给定一个 元素升序的、无重复数字的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标（下标从 0 开始），否则返回 -1

数据范围：0 \le len(nums) \le 2\times10^50≤*l**e**n*(*n**u**m**s*)≤2×105 ， 数组中任意值满足 |val| \le 10^9∣*v**a**l*∣≤109

进阶：时间复杂度 O(\log n)*O*(log*n*) ，空间复杂度 O(1)*O*(1)

## 示例1

输入：

```
[-1,0,3,4,6,10,13,14],13
```

返回值：

```
6
```

说明：

```
13 出现在nums中并且下标为 6     
```

## 示例2

输入：

```
[],3
```

返回值：

```
-1
```

说明：

```
nums为空，返回-1     
```

## 示例3

输入：

```
[-1,0,3,4,6,10,13,14],2
```

返回值：

```
-1
```

说明：

```
2 不存在nums中因此返回 -1  
```

```java
import java.util.*;

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型一维数组 
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        // 从数组首尾开始，直到二者相遇
        while(l <= r) {
            // 每次检查中点的值
            int m = (l + r) / 2;
            if(nums[m] == target) {
                return m;
            }
            // 进入左的区间
            if(nums[m] > target) {
                r = m - 1;
            } else { // 进入右的区间
                l = m + 1;
            }
        }
        return -1;
    }
}
```

# **BM18** **二维数组中的查找**

## 描述

在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

[

[1,2,8,9],
[2,4,9,12],
[4,7,10,13],
[6,8,11,15]

]

给定 target = 7，返回 true。

给定 target = 3，返回 false。

数据范围：矩阵的长宽满足 0 \le n,m \le 5000≤*n*,*m*≤500 ， 矩阵中的值满足 0 \le val \le 10^90≤*v**a**l*≤109
进阶：空间复杂度 O(1)*O*(1) ，时间复杂度 O(n+m)*O*(*n*+*m*)

## 示例1

输入：

```
7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]
```

返回值：

```
true
```

说明：

```
存在7，返回true    
```

## 示例2

输入：

```
1,[[2]]
```

返回值：

```
false
```

## 示例3

输入：

```
3,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]
```

返回值：

```
false
```

说明：

```
不存在3，返回false  
```

首先看四个角，左上与右下必定为最小值与最大值，而左下与右上就有规律了：**左下元素大于它上方的元素，小于它右方的元素，右上元素与之相反**。既然左下角元素有这么一种规律，相当于将要查找的部分分成了一个大区间和小区间，每次与左下角元素比较，我们就知道目标值应该在哪部分中，于是可以利用分治思维来做。

**具体做法：**

- step 1：首先获取矩阵的两个边长，判断特殊情况。
- step 2：首先以左下角为起点，若是它小于目标元素，则往右移动去找大的，若是他大于目标元素，则往上移动去找小的。
- step 3：若是移动到了矩阵边界也没找到，说明矩阵中不存在目标值。

**图示：**

![图片说明](https://uploadfiles.nowcoder.com/images/20210727/397721558_1627369615572/81B83FAE4B34DCEFE9C1EB670AE1CCB0)

```java
public class Solution {
    public boolean Find(int target, int [][] array) {
        if(array.length == 0) {
            return false;
        }
        int n = array.length;
        if(array[0].length == 0) {
            return false;
        }
        int m = array[0].length;
        // 从左下角的元素开始往左或者往上
        for(int i = n - 1, j = 0; i >= 0 && j < m; ) {
            // 元素较大，往上走
            if(array[i][j] > target) {
                i--;
            }
            // 元素较小，往右走
            else if(array[i][j] < target) {
                j++;
            } else {
                return true;
            }
        }
        return false;
    }
}
```

# **BM19** **寻找峰值**

## 描述

给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。

1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于

2.假设 nums[-1] = nums[n] = -\infty−∞

3.对于所有有效的 i 都有 nums[i] != nums[i + 1]

4.你可以使用O(logN)的时间复杂度实现此问题吗？

数据范围：

1 \le nums.length \le 2\times 10^5 \1≤*n**u**m**s*.*l**e**n**g**t**h*≤2×105 

-2^{31}<= nums[i] <= 2^{31} - 1−231<=*n**u**m**s*[*i*]<=231−1

如输入[2,4,1,2,7,8,4]时，会形成两个山峰，一个是索引为1，峰值为4的山峰，另一个是索引为5，峰值为8的山峰，如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634212356346/9EB9CD58B9EA5E04C890326B5C1F471F)

## 示例1

输入：

```
[2,4,1,2,7,8,4]
```

返回值：

```
1
```

说明：

```
4和8都是峰值元素，返回4的索引1或者8的索引5都可以
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型一维数组 
     * @return int整型
     */
    public int findPeakElement (int[] nums) {
        int l = 0, r = nums.length - 1;
        while(l < r) {
            int m = l + (r - l) / 2;
            if(nums[m] > nums[m + 1]) {
                r = m;
            } else {
                l = m + 1;
            }
        }
        return r;
    }
}
```

# **BM20** **数组中的逆序对**

## 描述

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007


数据范围： 对于 50\%50% 的数据, size\leq 10^4*s**i**z**e*≤104
对于 100\%100% 的数据, size\leq 10^5*s**i**z**e*≤105

数组中所有数字的值满足 0 \le val \le 10000000≤*v**a**l*≤1000000



要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(nlogn)*O*(*n**l**o**g**n*)

### 输入描述：

题目保证输入的数组中没有的相同的数字

## 示例1

输入：

```
[1,2,3,4,5,6,7,0]
```

返回值：

```
7
```

```java
public class Solution {
    private int mod = 1000000007;
    
    public int mergeSort(int left, int right, int[] data, int[] temp){
        // 停止划分
        if(left >= right) {
            return 0;
        }
        // 取中间
        int mid = (left + right) / 2;
        // 左右划分合并
        int res = mergeSort(left, mid, data, temp) + mergeSort(mid + 1, right, data, temp);
        // 防止溢出
        res %= mod;
        int i = left, j = mid + 1;
        for(int k = left; k <= right; k++) {
            temp[k] = data[k];
        }
        for(int k = left; k <= right; k++) {
            if(i == mid + 1) {
                data[k] = temp[j++];
            }
            else if(j == right + 1 || temp[i] <= temp[j]) {
                data[k] = temp[i++];
            }
            // 左边比右边大，答案增加
            else {
                data[k] = temp[j++];
                // 统计逆序对
                res += mid - i + 1;
            }
        }
        return res % mod;
    }
     
    public int InversePairs(int [] array) {
        int n = array.length;
        int[] res = new int[n];
        return mergeSort(0, n - 1, array, res);
    }
}
```

# **BM21** **旋转数组的最小数字**

## 描述

有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。

数据范围：1 \le n \le 100001≤*n*≤10000，数组中任意元素的值: 0 \le val \le 100000≤*v**a**l*≤10000

要求：空间复杂度：O(1)*O*(1) ，时间复杂度：O(logn)*O*(*l**o**g**n*)

## 示例1

输入：

```
[3,4,5,1,2]
```

返回值：

```
1
```

```java
import java.util.*;
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        int left = 0;
        int right = array.length - 1;
        while(left < right) {
            int mid = (left + right) / 2;
            // 最小的数字在mid右边
            if(array[mid] > array[right]) {
                left = mid + 1;
            }
            // 无法判断，一个一个试
            else if(array[mid] == array[right]) {
                right--;
            }
            // 最小数字要么是mid左边
            else {
                right = mid;
            }
        }
        return array[left];
    }
}
```

# **BM22** **比较版本号**

## 描述

牛客项目发布项目版本时会有版本号，比如1.02.11，2.14.4等等

现在给你2个版本号version1和version2，请你比较他们的大小

版本号是由修订号组成，修订号与修订号之间由一个"."连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号

每个版本号至少包含1个修订号。

修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。

比较规则：

一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如"0.1"和"0.01"的版本号是相等的

二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，"1.1"的版本号小于"1.1.1"。因为"1.1"的版本号相当于"1.1.0"，第3位修订号的下标为0，小于1

三. version1 > version2 返回1，如果 version1 < version2 返回-1，不然返回0.

数据范围：

1 <= version1.length, version2.length <= 10001<=*v**e**r**s**i**o**n*1.*l**e**n**g**t**h*,*v**e**r**s**i**o**n*2.*l**e**n**g**t**h*<=1000

version1 和 version2 的修订号不会超过int的表达范围，即不超过 **32 位整数** 的范围


进阶：  时间复杂度 O(n)

## 示例1

输入：

```
"1.1","2.1"
```

返回值：

```
-1
```

说明：

```
version1 中下标为 0 的修订号是 "1"，version2 中下标为 0 的修订号是 "2" 。1 < 2，所以 version1 < version2，返回-1
```

```java
import java.util.*;

public class Solution {

    public int compare (String version1, String version2) {
        int n1 = version1.length();
        int n2 = version2.length();
        int i = 0, j = 0;
        // 直到某个字符串结束
        while(i < n1 || j < n2) {
            long num1 = 0;
            // 从下一个点前截取数字
            while(i < n1 && version1.charAt(i) != '.') {
                num1 = num1 * 10 + (version1.charAt(i) - '0');
                i++;
            }
            // 跳过点
            i++;
            long num2 = 0;
            // 从下一个点前截取数字
            while(j < n2 && version2.charAt(j) != '.') {
                num2 = num2 * 10 + (version2.charAt(j) - '0');
                j++;
            }
            // 跳过点
            j++;
            // 比较数字大小
            if(num1 > num2) {
                return 1;
            }
            if(num1 < num2) {
                return -1;
            }
        }
        // 版本号相同
        return 0;
    }
}
```

# **BM23** **二叉树的前序遍历**

给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

数据范围：二叉树的节点数量满足 0 \le n \le 100 \0≤*n*≤100 ，二叉树节点的值满足 1 \le val \le 100 \1≤*v**a**l*≤100 ，树的各节点的值各不相同

示例 1：![img](https://uploadfiles.nowcoder.com/images/20211111/392807_1636599059575/FE67E09E9BA5661A7AB9DF9638FB1FAC)

## 示例1

输入：

```
{1,#,2,3}
```

复制

返回值：

```
[1,2,3]
```

**知识点：二叉树递归**

递归是一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。因此递归过程，最重要的就是查看能不能讲原本的问题分解为更小的子问题，这是使用递归的关键。

而二叉树的递归，则是将某个节点的左子树、右子树看成一颗完整的树，那么对于子树的访问或者操作就是对于原树的访问或者操作的子问题，因此可以自我调用函数不断进入子树。

从上述前序遍历的解释中我们不难发现，它存在递归的子问题：每次访问一个节点之后，它的左子树是一个要前序遍历的子问题，它的右子树同样是一个要前序遍历的子问题。那我们可以用递归处理：

- **终止条件：** 当子问题到达叶子节点后，后一个不管左右都是空，因此遇到空节点就返回。
- **返回值：** 每次处理完子问题后，就是将子问题访问过的元素返回，依次存入了数组中。
- **本级任务：** 每个子问题优先访问这棵子树的根节点，然后递归进入左子树和右子树。

**具体做法：**

- step 1：准备数组用来记录遍历到的节点值，Java可以用List，C++可以直接用vector。
- step 2：从根节点开始进入递归，遇到空节点就返回，否则将该节点值加入数组。
- step 3：依次进入左右子树进行递归。

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return int整型一维数组
     */
    public void preOrder(List<Integer> list, TreeNode root) {
        if(root == null){
            return;
        }
        list.add(root.val);
        // 左子树
        preOrder(list, root.left);
        // 右子树
        preOrder(list, root.right);
    }
    
    public int[] preorderTraversal (TreeNode root) {
        // write code here
        List<Integer> list = new ArrayList<>();
        preOrder(list, root);
        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        return res;
    }
}
```

# **BM26** **求二叉树的层序遍历**

## 描述

给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）
例如：
给定的二叉树是{3,9,20,#,#,15,7},
![img](https://uploadfiles.nowcoder.com/images/20210114/999991351_1610616074120/036DC34FF19FB24652AFFEB00A119A76)
该二叉树层序遍历的结果是
[
[3],
[9,20],
[15,7]

]

数据范围：二叉树的节点数满足 1 \le n \le 10^5 \1≤*n*≤105 

## 示例1

输入：

```
{1,2}
```

返回值：

```
[[1],[2]]
```

## 示例2

输入：

```
{1,2,3,4,#,#,5}
```

返回值：

```
[[1],[2,3],[4,5]]
```

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @return int整型ArrayList<ArrayList<>>
     */
    public ArrayList<ArrayList<Integer>> levelOrder (TreeNode root) {
        ArrayList<ArrayList<Integer>> res = new ArrayList();
        // 如果为空，直接返回空数组
        if(root == null) {
            return res;
        }
        // 队列存储，进行层序遍历
        Queue<TreeNode> q = new ArrayDeque<TreeNode>();
        q.add(root);
        while(!q.isEmpty()) {
            // 记录二叉树的某一行
            ArrayList<Integer> row = new ArrayList();
            int n = q.size();
            // 因为先进入的是根节点，故每层节点多少，队列的大小就是多少
            for(int i = 0; i < n; i++) {
                TreeNode cur = q.poll();
                row.add(cur.val);
                // 若左右孩子存在，则存入左右孩子作为下一个层次
                if(cur.left != null) {
                    q.add(cur.left);
                }
                if(cur.right != null) {
                    q.add(cur.right);
                }
            }
            res.add(row);
        }
        return res;
    }
}
```

# **BM27** **按之字形顺序打印二叉树**

## 描述

给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）

数据范围：0 \le n \le 15000≤*n*≤1500,树上每个节点的val满足 |val| <= 1500∣*v**a**l*∣<=1500
要求：空间复杂度：O(n)*O*(*n*)，时间复杂度：O(n)*O*(*n*)

例如：
给定的二叉树是{1,2,3,#,#,4,5}
![img](https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05)
该二叉树之字形层序遍历的结果是

[

[1],

[3,2],

[4,5]

]

## 示例1

输入：

```
{1,2,3,#,#,4,5}
```

复制

返回值：

```
[[1],[3,2],[4,5]]
```

复制

说明：

```
如题面解释，第一层是根节点，从左到右打印结果，第二层从右到左，第三层从左到右。     
```

```java
import java.util.*;
import java.util.ArrayList;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }
}
*/
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        TreeNode head = pRoot;
        ArrayList<ArrayList<Integer> > res = 
            new ArrayList<ArrayList<Integer>>();
        if(head == null) {
            // 如果是空，则直接返回list
            return res;
        }
        // 队列存储，进行层次遍历
        Queue<TreeNode> temp = new LinkedList<TreeNode>();
        temp.offer(head);
        TreeNode p;
        boolean flag = true;
        while(!temp.isEmpty()) {
            // 记录二叉树的某一行
            ArrayList<Integer> row = new ArrayList<Integer>();
            int n = temp.size();
            // 奇数行反转，偶数行不反转
            flag = !flag;
            // 因为先进入的是根节点，故每层节点多少，队列大小就是多少
            for(int i = 0; i < n; i++) {
                p = temp.poll();
                row.add(p.val);
                // 若是左右孩子存在，则存入左右孩子作为下一个层次
                if(p.left != null) {
                    temp.offer(p.left);
                }
                if(p.right != null) {
                    temp.offer(p.right);
                }
            }
            // 奇数行反转，偶数行不反转
            if(flag) {
                Collections.reverse(row);
            }
            res.add(row);
        }
        return res;
    }

}
```

# **BM28** **二叉树的最大深度**

## 描述

求给定二叉树的最大深度，

深度是指树的根节点到任一叶子节点路径上节点的数量。

最大深度是所有叶子节点的深度的最大值。

（注：叶子节点是指没有子节点的节点。）

数据范围：0 \le n \le 1000000≤*n*≤100000，树上每个节点的val满足 |val| \le 100∣*v**a**l*∣≤100
要求： 时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
{1,2}
```

返回值：

```
2
```

## 示例2

输入：

```
{1,2,3,4,#,#,5}
```

返回值：

```
3
```

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    public int maxDepth (TreeNode root) {
        if(root == null) {
            return 0;
        }
        return maxHigh(root, 0);
    }
    
    public int maxHigh(TreeNode root, int high) {
        if(root == null) {
            return high;
        }
        return Math.max(maxHigh(root.left, high + 1), maxHigh(root.right, high + 1)); 
    }
}
```

# **BM29** **二叉树中和为某一值的路径(一)**

## 描述

给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。

1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点

2.叶子节点是指没有子节点的节点

3.路径只能从父节点到子节点，不能从子节点到父节点

4.总节点数目为n
例如：
给出如下的二叉树，\ sum=22 *s**u**m*=22，
![img](https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159)
返回true，因为存在一条路径 5\to 4\to 11\to 25→4→11→2的节点值之和为 22

数据范围：

1.树上的节点数满足 0 \le n \le 100000≤*n*≤10000

2.每 个节点的值都满足 |val| \le 1000∣*v**a**l*∣≤1000

要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

进阶：空间复杂度 O(树的高度)*O*(树的高度)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
{5,4,8,1,11,#,9,#,#,2,7},22
```

返回值：

```
true
```

```java
import java.util.*;
/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    public boolean hasPathSum (TreeNode root, int sum) {
        // 空节点找不到路径
        if(root == null) {
            return false;
        }
        // 叶子节点，且路径和为sum
        if(root.left == null && root.right == null && sum - root.val == 0) {
            return true;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

# **BM30** **二叉搜索树与双向链表**

## 描述

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示

![img](https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2)

数据范围：输入二叉树的节点数 0 \le n \le 10000≤*n*≤1000，二叉树中每个节点的值 0\le val \le 10000≤*v**a**l*≤1000
要求：空间复杂度O(1)*O*(1)（即在原树上操作），时间复杂度 O(n)*O*(*n*)

注意:

1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继
2.返回链表中的第一个节点的指针
3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构

4.你不用输出双向链表，程序会根据你的返回值自动打印输出

### 输入描述：

二叉树的根节点

### 返回值描述：

双向链表的其中一个头节点。

## 示例1

输入：

```
{10,6,14,4,8,12,16}
```

复制

返回值：

```
From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;
```

说明：

```
输入题面图中二叉树，输出的时候将双向链表的头节点返回即可。  
```

```java
import java.util.*;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public TreeNode Convert(TreeNode pRootOfTree) {
        if(pRootOfTree == null) {
            return null;
        }
        // 设置栈用于遍历
        Stack<TreeNode> s = new Stack<TreeNode>();
        TreeNode head = null;
        TreeNode pre = null;
        // 确认第一个遍历到最左，即为首位
        boolean isFirst = true;
        while(pRootOfTree != null || !s.isEmpty()) {
            // 直到没有左节点
            while(pRootOfTree != null) {
                s.push(pRootOfTree);
                pRootOfTree = pRootOfTree.left;
            }
            pRootOfTree = s.pop();
            // 最左元素即表头
            if(isFirst) {
                head = pRootOfTree;
                pre = head;
                isFirst = false;
            } else {
                pre.right = pRootOfTree;
                pRootOfTree.left = pre;
                pre = pRootOfTree;
            }
            pRootOfTree = pRootOfTree.right;
        }
        return head;
    }
}
```

# **BM31** **对称的二叉树**

## 描述

给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）
例如：                 下面这棵二叉树是对称的
![img](https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F)
下面这棵二叉树不对称。
![img](https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372)

数据范围：节点数满足 0 \le n \le 10000≤*n*≤1000，节点上的值满足 |val| \le 1000∣*v**a**l*∣≤1000

要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

备注：

你可以用递归和迭代两种方法解决这个问题

## 示例1

输入：

```
{1,2,2,3,4,4,3}
```

复制

返回值：

```
true
```

```java
import java.util.*;
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
// 队列做法
public class Solution {
    boolean isSymmetrical(TreeNode pRoot) {
        // 空树是对称的
        if(pRoot == null) {
            return true;
        }
        Queue<TreeNode> q1 = new LinkedList<TreeNode>();
        Queue<TreeNode> q2 = new LinkedList<TreeNode>();
        q1.offer(pRoot.left);
        q2.offer(pRoot.right);
        while(!q1.isEmpty() && !q2.isEmpty()) {
            // 分别从左边和右边弹出节点
            TreeNode left = q1.poll();
            TreeNode right = q2.poll();
            // 都为空暂时对称
            if(left == null && right == null) {
                continue;
            }
            // 某一个不为空，则不对称
            if(left == null || right == null || right.val != left.val) {
                return false;
            }
            // 从左往右加入队列
            q1.offer(left.left);
            q1.offer(left.right);
            // 从右往左加入队列
            q2.offer(right.right);
            q2.offer(right.left);
        }
        return true;
    }
}

// 递归
public class Solution {
    boolean isSymmetrical(TreeNode pRoot) {
        // 空树是对称的
        if(pRoot == null) {
            return true;
        }
        return f(pRoot.left, pRoot.right);
    }
    
    boolean f(TreeNode t1, TreeNode t2) {
        if(t1 == null && t2 == null) {
            return true;
        }
        if(t1 != null && t2 != null) {
            return t1.val == t2.val && f(t1.left, t2.right) && f(t1.right, t2.left);
        }
        return false;
    }
}
```

# **BM32** **合并二叉树**

## 描述

已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：
两颗二叉树是:
                                  Tree 1

![img](https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821337680/9E290CFD3730B9B08A5CEFF25799608F)

​                                    Tree 2
![img](https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821376266/DD0A63560E770A8510049C5182E6E622)
​                                  合并后的树为
![img](https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821404541/9CB750F8909D5985C0D01D8B71AD58BA)

数据范围：树上节点数量满足 0 \le n \le 5000≤*n*≤500，树上节点的值一定在32位整型范围内。

进阶：空间复杂度 O(1)*O*(1) ，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
{1,3,2,5},{2,1,3,#,4,#,7}
```

返回值：

```
{3,4,5,5,4,#,7}
```

说明：

```
如题面图 
```

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    public TreeNode mergeTrees (TreeNode t1, TreeNode t2) {
        // 若只有一个节点返回另一个，两个都为null自然返回null
        if (t1 == null)
            return t2;
        if (t2 == null)
            return t1;
        // 根左右的方式递归
        TreeNode head = new TreeNode(t1.val + t2.val);
        head.left = mergeTrees(t1.left, t2.left);
        head.right = mergeTrees(t1.right, t2.right);
        return head;
    }
}
```

# **BM33** **二叉树的镜像**

## 描述

操作给定的二叉树，将其变换为源二叉树的镜像。

数据范围：二叉树的节点数 0 \le n \le 10000≤*n*≤1000 ， 二叉树每个节点的值 0\le val \le 10000≤*v**a**l*≤1000

要求： 空间复杂度 O(n)*O*(*n*) 。本题也有原地操作，即空间复杂度 O(1)*O*(1) 的解法，时间复杂度 O(n)*O*(*n*)

比如：

源二叉树

![img](https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302001586/420B82546CFC9760B45DD65BA9244888)

镜像二叉树

![img](https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302036250/AD8C4CC119B15070FA1DBAA1EBE8FC2A)

## 示例1

输入：

```
{8,6,10,5,7,9,11}
```

复制

返回值：

```
{8,10,6,11,9,7,5}
```

说明：

```
如题面所示  
```

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
具体做法：
step 1：先深度最左端的节点，遇到空树返回，处理最左端的两个子节点交换位置。
step 2：然后进入右子树，继续按照先左后右再回中的方式访问。
step 3：再返回到父问题，交换父问题两个子节点的值。
 */

public class Solution {
    public TreeNode Mirror (TreeNode pRoot) {
        // 空树返回
        if(pRoot == null) {
            return null;
        }
        // 先递归子树
        TreeNode left = Mirror(pRoot.left);
        TreeNode right = Mirror(pRoot.right);
        // 交换
        pRoot.left = right;
        pRoot.right = left;
        return pRoot;
    }
}
```

# **BM34** **判断是不是二叉搜索树**

## 描述

给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。

二叉搜索树满足每个节点的左子树上的所有节点均严格小于当前节点且右子树上的所有节点均严格大于当前节点。

例：

![img](https://uploadfiles.nowcoder.com/images/20211109/392807_1636440937987/9C31F319601A5B78D34F62FF77A02A11)

图1

![img](https://uploadfiles.nowcoder.com/images/20211109/392807_1636440984427/5E5B576E11CB2C96724680C94755ABCB)

图2

数据范围：节点数量满足 1 \le n\le 10^4 \1≤*n*≤104 ，节点上的值满足 -2^{31} \le val \le 2^{31}-1\−231≤*v**a**l*≤231−1 

## 示例1

输入：

```
{1,2,3}
```

返回值：

```
false
```

说明：

```
如题面图1  
```

```java
具体做法：
step 1：首先递归到最左，初始化maxLeft与pre。
step 2：然后往后遍历整棵树，依次连接pre与当前节点，并更新pre。
step 3：左子树如果不是二叉搜索树返回false。
step 4：判断当前节点是不是小于前置节点，更新前置节点。
step 5：最后由右子树的后面节点决定。
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    private int pre = Integer.MAX_VALUE;
    
    // 中序遍历
    public boolean isValidBST (TreeNode root) {
        if(root == null) {
            return true;
        }
        if(!isValidBST(root.left)) {
            return false;
        }
        if(root.val < pre) {
            return false;
        }
        // 更新最值
        pre = root.val;
        // 再进入右子树
        return isValidBST(root.right);
    }
}
```

# BM35 判断是不是完全二叉树

## 描述

给定一个二叉树，确定他是否是一个完全二叉树。

完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）

数据范围：节点数满足 1 \le n \le 100 \1≤*n*≤100 

样例图1：

![img](https://uploadfiles.nowcoder.com/images/20211112/392807_1636687704633/3FDF585A954EFF629B41FD21BA20B0C9)

样例图2：

![img](https://uploadfiles.nowcoder.com/images/20211112/392807_1636687742831/942721EB3583D230F79D69B3097D3416)

样例图3：

![img](https://uploadfiles.nowcoder.com/images/20211112/392807_1636687774162/1D0ED443BD0A777690EF55BABCD978D5)

## 示例1

输入：

```
{1,2,3,4,5,6}
```

返回值：

```
true
```

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    public boolean isCompleteTree (TreeNode root) {
        // 空树一定是完全二叉树
        if(root == null)
            return true;
        // 辅助队列
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        TreeNode cur;
        // 定义一个首次出现的标记位
        boolean notComplete = false;
        while(!queue.isEmpty()){
            cur = queue.poll();
            // 标记第一次遇到空节点
            if(cur == null){
                notComplete = true;
                continue;
            }
            // 后续访问已经遇到空节点了，说明经过了叶子
            if(notComplete)
                return false;
            queue.offer(cur.left);
            queue.offer(cur.right);
        }
        return true;
    }
}
```

# **BM36** **判断是不是平衡二叉树**

## 描述

输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。

在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树

**平衡二叉树**（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

样例解释：

![img](https://uploadfiles.nowcoder.com/images/20210918/382300087_1631935149594/D55A07912354B3AB7E9F2F5EA27CB7D6)

样例二叉树如图，为一颗平衡二叉树

注：我们约定空树是平衡二叉树。

数据范围：n \le 100*n*≤100,树上节点的val值满足 0 \le n \le 10000≤*n*≤1000

要求：空间复杂度O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

### 输入描述：

输入一棵二叉树的根节点

### 返回值描述：

输出一个布尔类型的值

## 示例1

输入：

```
{1,2,3,4,5,6,7}
```

返回值：

```
true
```

```java
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if (root == null) return true;
        //判断左子树和右子树是否符合规则，且深度不能超过2
        return IsBalanced_Solution(root.left) && IsBalanced_Solution(root.right) && Math.abs(deep(root.left) - deep(root.right)) < 2;
    }
    //判断二叉树深度
    public int deep(TreeNode root) {
        if (root == null) return 0;
        return Math.max(deep(root.left), deep(root.right)) + 1;
    }
}
```

# **BM37** **二叉搜索树的最近公共祖先**

## 描述

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

1.对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.

2.二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值

3.所有节点的值都是唯一的。

4.p、q 为不同节点且均存在于给定的二叉搜索树中。

数据范围:

3<=节点总数<=10000

0<=节点值<=10000

如果给定以下搜索二叉树: {7,1,12,0,4,11,14,#,#,3,5}，如下图:

![img](https://uploadfiles.nowcoder.com/images/20211110/301499_1636536407371/36404CF45DDCB5834FC8BBFEA318831A)

## 示例1

输入：

```
{7,1,12,0,4,11,14,#,#,3,5},1,12
```

复制

返回值：

```
7
```

说明：

```
节点1 和 节点12的最近公共祖先是7
```

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    // 求得根节点到目标节点的路径
    public ArrayList<Integer> getPath(TreeNode root, int target) {
        ArrayList<Integer> path = new ArrayList<Integer>();
        TreeNode node = root;
        // 节点值都不同，可以直接用值比较
        while(node.val != target) {
            path.add(node.val);
            // 小的在左子树
            if(target < node.val) {
                node = node.left;
            } // 大的在右子树
            else {
                node = node.right;
            }
        }
        path.add(node.val);
        return path;
    }
    
    public int lowestCommonAncestor (TreeNode root, int p, int q) {
        // 求根节点到两个节点的路径
        ArrayList<Integer> path_p = getPath(root, p);
        ArrayList<Integer> path_q = getPath(root, q);
        int res = 0;
        // 比较两个路径，找到第一个不同的点
        for(int i = 0; i < path_p.size() && i < path_q.size(); i++) {
            int x = path_p.get(i);
            int y = path_q.get(i);
            // 最后一个相同的节点就是最近公共祖先
            if(x == y) {
                res = path_p.get(i);
            } else {
                break;
            }
        }
        return res;
    }
}
```

# **BM38** **在二叉树中找到两个节点的最近公共祖先**

## 描述

给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。

数据范围：树上节点数满足 1 \le n \le 10^5 \1≤*n*≤105 , 节点值val满足区间 [0,n)

要求：时间复杂度 O(n)*O*(*n*)

注：本题保证二叉树中每个节点的val值均不相同。

如当输入{3,5,1,6,2,0,8,#,#,7,4},5,1时，二叉树{3,5,1,6,2,0,8,#,#,7,4}如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206667843/D2B5CA33BD970F64A6301FA75AE2EB22)

所以节点值为5和节点值为1的节点的最近公共祖先节点的节点值为3，所以对应的输出为3。

节点本身可以视为自己的祖先

## 示例1

输入：

```
{3,5,1,6,2,0,8,#,#,7,4},5,1
```

返回值：

```
3
```

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        // 记录遍历到的每个节点的父节点
        Map<Integer, Integer> parent = new HashMap<>();
        Queue<TreeNode> queue = new LinkedList<>();
        // 根节点没有父节点，给他默认一个值
        parent.put(root.val, Integer.MIN_VALUE);
        queue.add(root);
        // 直到两个节点都找到为止
        while(!parent.containsKey(o1) || !parent.containsKey(o2)) {
            // 队列是一边进一边出，这里poll方法是出队
            TreeNode node = queue.poll();
            if(node.left != null) {
                // 左子节点不为空，记录下他的父节点
                parent.put(node.left.val, node.val);
                // 左子节点不为空，吧他加入到队列中
                queue.add(node.left);
            }
            // 右节点同上
            if(node.right != null) {
                parent.put(node.right.val, node.val);
                queue.add(node.right);
            }
        }
        Set<Integer> ancestors = new HashSet<>();
        // 记录下o1和他的祖先节点，从o1节点开始一直到根节点
        while(parent.containsKey(o1)) {
            ancestors.add(o1);
            o1 = parent.get(o1);
        }
        // 查看o1和他的祖先节点是否包含o2节点，如果不包含再看是否包含o2的父节点
        while(!ancestors.contains(o2)) {
            o2 = parent.get(o2);
        }
        return o2;
    }
}
```

# **BM39** **序列化二叉树**

## 描述

请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。

二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）

二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。

例如，可以根据层序遍历的方案序列化，如下图:

![img](https://uploadfiles.nowcoder.com/images/20210910/557336_1631245540483/320409CB186FCD18144519959D510D7E)

层序序列化(即用函数Serialize转化)如上的二叉树转为"{1,2,3,#,#,6,7}"，再能够调用反序列化(Deserialize)将"{1,2,3,#,#,6,7}"构造成如上的二叉树。

当然你也可以根据满二叉树结点位置的标号规律来序列化，还可以根据先序遍历和中序遍历的结果来序列化。不对序列化之后的字符串进行约束，所以欢迎各种奇思妙想。

数据范围：节点数 n \le 100*n*≤100，树上每个节点的值满足 0 \le val \le 1500≤*v**a**l*≤150

要求：序列化和反序列化都是空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
{1,2,3,#,#,6,7}
```

返回值：

```
{1,2,3,#,#,6,7}
```

说明：

```
如题面图    
```

```java
import java.util.*;
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    int INF = 0x3f3f3f;
    TreeNode emptyNode = new TreeNode(INF);
    
    String Serialize(TreeNode root) {
        if(root == null) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        // 使用队列进行层序遍历，起始先将root放入队列
        Deque<TreeNode> d = new ArrayDeque<>();
        d.addLast(root);
        while(!d.isEmpty()) {
            // 每次从队列中取出元素进行拼接，包括正常节点和叶子节点对应的首位空节点
            TreeNode poll = d.pollFirst();
            sb.append(poll.val + "_");
            // 如果取出的节点不为占位节点，则继续往下拓展，同时防止占位节点不继续往下拓展
            if(!poll.equals(emptyNode)) {
                d.addLast(poll.left != null ? poll.left : emptyNode);
                d.addLast(poll.right != null ? poll.right : emptyNode);
            }
        }
        return sb.toString();
    }
    
    TreeNode Deserialize(String str) {
        if(str.equals("")) {
            return null;
        }
        // 根据分隔符进行分割
        String[] ss = str.split("_");
        int n = ss.length;
        // 怎么序列化就怎么反序列化
        // 使用队列进行层序遍历，起始先将root构建出来，并放入队列
        TreeNode root = new TreeNode(Integer.parseInt(ss[0]));
        Deque<TreeNode> d = new ArrayDeque<>();
        d.addLast(root);
        for(int i = 1; i < n - 1; i += 2) {
            TreeNode poll = d.pollFirst();
            // 每次从中取出左右对应节点对应的val
            int a = Integer.parseInt(ss[i]), b = Integer.parseInt(ss[i + 1]);
            // 如果左节点对应的值不是INF，则构建真实节点
            if(a != INF) {
                poll.left = new TreeNode(a);
                d.addLast(poll.left);
            }
            if(b != INF) {
                poll.right = new TreeNode(b);
                d.addLast(poll.right);
            }
        }
        return root;
    }
}
```

# **BM40** **重建二叉树**

## 描述



给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。

例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。

![img](https://uploadfiles.nowcoder.com/images/20210717/557336_1626504921458/776B0E5E0FAD11A6F15004B29DA5E628)

提示:

1.vin.length == pre.length

2.pre 和 vin 均无重复元素

3.vin出现的元素均出现在 pre里

4.只需要返回根结点，系统会自动输出整颗树做答案对比

数据范围：n \le 2000*n*≤2000，节点的值 -10000 \le val \le 10000−10000≤*v**a**l*≤10000

要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
[1,2,4,7,3,5,6,8],[4,7,2,1,5,3,8,6]
```

返回值：

```
{1,2,3,4,#,5,6,#,7,#,#,8}
```

说明：

```
返回根节点，系统会输出整颗二叉树对比结果，重建结果如题面图示
```

```java
import java.util.*;
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] vin) {
        int n = pre.length;
        int m = vin.length;
        // 每个遍历都不能为0
        if(n == 0 || m == 0) {
            return null;
        }
        // 构建根节点
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < vin.length; i++) {
            // 找到中序遍历中的前序第一个元素
            if(pre[0] == vin[i]) {
                // 构建左子树
                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(vin, 0, i));
                // 构建右子树
                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(vin, i + 1, vin.length));
                break;
            }
        }
        return root;
    }
}
```

# **BM41** **输出二叉树的右视图**

## 描述

请根据二叉树的前序遍历，中序遍历恢复二叉树，并打印出二叉树的右视图

数据范围： 0 \le n \le 100000≤*n*≤10000
要求： 空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

如输入[1,2,4,5,3],[4,2,5,1,3]时，通过前序遍历的结果[1,2,4,5,3]和中序遍历的结果[4,2,5,1,3]可重建出以下二叉树：

![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634208293748/10FB15C77258A991B0028080A64FB42D)

所以对应的输出为[1,3,5]。

## 示例1

输入：

```
[1,2,4,5,3],[4,2,5,1,3]
```

返回值：

```
[1,3,5]
```

```java
import java.util.*;
public class Solution {
    public Map<Integer, Integer> index;
    // 建树函数
    // 四个int参数分别是前序最左节点下标，前序最右节点下标
    // 中序最左节点下标，中序最右节点坐标
    public TreeNode buildTree(int[] xianxu, int l1, int r1, int[] zhongxu, int l2, int r2){
        if(l1 > r1 || l2 > r2)
            return null;
        // 前序遍历中的第一个节点就是根节点
        int xianxu_root = l1;
        // 在中序遍历中定位根节点
        int zhongxu_root = index.get(xianxu[xianxu_root]);
        TreeNode root = new TreeNode(xianxu[xianxu_root]);
        // 得到左子树中的节点数目
        int leftsize = zhongxu_root - l2;
        root.left = buildTree(xianxu, l1 + 1, l1 + leftsize, zhongxu, l2, zhongxu_root - 1);
        root.right = buildTree(xianxu, l1 + leftsize + 1, r1, zhongxu, zhongxu_root + 1, r2);
        return root;
    }
    // 层次遍历
    public ArrayList<Integer> rightSideView(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<Integer>();
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        q.offer(root);
        while(!q.isEmpty()){
            // 队列中的大小即是这一层的节点树
            int size = q.size(); 
            while(size-- != 0){
                TreeNode temp = q.poll();             
                if(temp.left != null) 
                    q.offer(temp.left);
                if(temp.right != null) 
                    q.offer(temp.right);
                // 最右元素
                if(size == 0) {
                    res.add(temp.val);
                }
            }
        }
        return res;
    }
    
    public int[] solve (int[] xianxu, int[] zhongxu) {
        index = new HashMap<Integer, Integer>();
        // 空节点
        if(xianxu.length == 0) 
            return new int[0];
        // 用哈希表标记中序节点在前序中的位置
        for(int i = 0; i < xianxu.length; i++) 
            index.put(zhongxu[i], i);
        // 建树
        TreeNode root = buildTree(xianxu, 0, xianxu.length - 1, zhongxu, 0, zhongxu.length - 1);
        // 获取右视图输出
        ArrayList<Integer> temp = rightSideView(root);
        // 转化为数组
        int[] res = new int[temp.size()]; 
        for(int i = 0; i < temp.size(); i++)
            res[i] = temp.get(i);
        return res;
    }
}
```

# **BM42** **用两个栈实现队列**

## 描述

用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。

数据范围： n\le1000*n*≤1000

要求：存储n个元素的空间复杂度为 O(n)*O*(*n*) ，插入与删除的时间复杂度都是 O(1)*O*(1)

## 示例1

输入：

```
["PSH1","PSH2","POP","POP"]
```

复制

返回值：

```
1,2
```

复制

说明：

```
"PSH1":代表将1插入队列尾部
"PSH2":代表将2插入队列尾部
"POP“:代表删除一个元素，先进先出=>返回1
"POP“:代表删除一个元素，先进先出=>返回2    
```

```java
import java.util.*;
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        // 将第一个栈中内容弹出放入第二个栈中
        while(!stack1.isEmpty()) {
            stack2.push(stack1.pop());
        }
        // 第二个栈栈顶是最先进来的元素，即队首
        int res = stack2.pop();
        // 再将第二个栈的元素放回第一个栈
        while(!stack2.isEmpty()) {
            stack1.push(stack2.pop());
        }
        return res;
    }
}
```

# **BM43** **包含min函数的栈**

## 描述

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。

此栈包含的方法有：

push(value):将value压入栈中

pop():弹出栈顶元素

top():获取栈顶元素

min():获取栈中最小元素

数据范围：操作数量满足 0 \le n \le 300 \0≤*n*≤300 ，输入的元素满足 |val| \le 10000 \∣*v**a**l*∣≤10000 
进阶：栈的各个操作的时间复杂度是 O(1)\*O*(1) ，空间复杂度是 O(n)\*O*(*n*) 

示例:

输入:  ["PSH-1","PSH2","MIN","TOP","POP","PSH1","TOP","MIN"]

输出:  -1,2,1,-1

解析:

"PSH-1"表示将-1压入栈中，栈中元素为-1

"PSH2"表示将2压入栈中，栈中元素为2，-1

“MIN”表示获取此时栈中最小元素==>返回-1

"TOP"表示获取栈顶元素==>返回2

"POP"表示弹出栈顶元素，弹出2，栈中元素为-1

"PSH1"表示将1压入栈中，栈中元素为1，-1

"TOP"表示获取栈顶元素==>返回1

“MIN”表示获取此时栈中最小元素==>返回-1

## 示例1

输入：

```
 ["PSH-1","PSH2","MIN","TOP","POP","PSH1","TOP","MIN"]
```

返回值：

```
-1,2,1,-1
```

```java
import java.util.*;
import java.util.Stack;

public class Solution {
    
    // 用于栈的 push 和 pop
    Stack<Integer> s1 = new Stack<Integer>();
    // 用于存储最小 min
    Stack<Integer> s2 = new Stack<Integer>();
    
    public void push(int node) {
        s1.push(node);
        if(s2.isEmpty() || s2.peek() > node) {
            s2.push(node);
        } else {
            // 重复加入栈顶
            s2.push(s2.peek());
        }
    }
    
    public void pop() {
        s1.pop();
        s2.pop();
    }
    
    public int top() {
        return s1.peek();
    }
    
    public int min() {
        return s2.peek();
    }
}
```

# **BM44** **有效括号序列**

## 描述

给出一个仅包含字符'(',')','{','}','['和']',的字符串，判断给出的字符串是否是合法的括号序列
括号必须以正确的顺序关闭，"()"和"()[]{}"都是合法的括号序列，但"(]"和"([)]"不合法。

数据范围：字符串长度 0\le n \le 100000≤*n*≤10000

要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
"()[]{}"
```

返回值：

```
true
```

```java
import java.util.*;

public class Solution {
    public boolean isValid (String s) {
        // 辅助栈
        Stack<Character> st = new Stack<Character>();
        // 遍历字符串
        for(int i = 0; i < s.length(); i++) {
            // 遇到左小括号
            if(s.charAt(i) == '(') {
                // 期待遇到右小括号
                st.push(')');
            }
            // 遇到左中括号
            else if(s.charAt(i) == '[') {
                // 期待遇到右中括号
                st.push(']');
            }
            // 遇到左大括号
            else if(s.charAt(i) == '{') {
                // 期待遇到右大括号
                st.push('}');
            }
            // 必须有左括号的情况下才能遇到右括号
            else if(st.isEmpty() || st.pop() != s.charAt(i)) {
                return false;
            }
        }
        return st.isEmpty();
    }
}
```

# **BM46** **最小的K个数**

## 描述

给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。

数据范围：0\le k,n \le 100000≤*k*,*n*≤10000，数组中每个数的大小0 \le val \le 10000≤*v**a**l*≤1000

要求：空间复杂度 O(n)*O*(*n*) ，时间复杂度 O(nlogn)*O*(*n**l**o**g**n*)

## 示例1

输入：

```
[4,5,1,6,2,7,3,8],4 
```

返回值：

```
[1,2,3,4]
```

说明：

```
返回最小的4个数即可，返回[1,3,2,4]也可以  
```

```java
import java.util.*;

public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList<Integer> res = new ArrayList<Integer>();
        // 排除特殊情况
        if(k == 0 || input.length == 0) {
            return res;
        }
        // 大根推
        PriorityQueue<Integer> q = new PriorityQueue<>((o1, o2) -> o2.compareTo(o1));
        // 构建一个k个大小的推
        for(int i = 0; i < k; i++) {
            q.offer(input[i]);
        }
        for(int i = k; i < input.length; i++) {
            // 较小的元素入堆
            if(q.peek() > input[i]) {
                q.poll();
                q.offer(input[i]);
            }
        }
        // 推中元素取出入数组
        for(int i = 0; i < k; i++) {
            res.add(q.poll());
        }
        return res;
    }
}
```

# **BM50** **两数之和**

## 描述

给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。

（注：**返回**的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到）

数据范围：2\leq len(numbers) \leq 10^52≤*l**e**n*(*n**u**m**b**e**r**s*)≤105，-10 \leq numbers_i \leq 10^9−10≤*n**u**m**b**e**r**s**i*≤109，0 \leq target \leq 10^90≤*t**a**r**g**e**t*≤109

要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(nlogn)*O*(*n**l**o**g**n*)

## 示例1

输入：

```
[3,2,4],6
```

返回值：

```
[2,3]
```

说明：

```
因为 2+4=6 ，而 2的下标为2 ， 4的下标为3 ，又因为 下标2 < 下标3 ，所以返回[2,3]  
```

```java
import java.util.*;

public class Solution {
    public int[] twoSum (int[] numbers, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        // 遍历数组
        for (int i = 0; i < numbers.length; i++) {
            // 将不包含 target - numbers[i]，装入 map 中，包含的话直接返回下标
            if(map.containsKey(target - numbers[i]))
                return new int[]{map.get(target - numbers[i]) + 1, i + 1};
            else
                map.put(numbers[i], i);
        }
        throw new IllegalArgumentException("No solution");
    }
}
```

# **BM51** **数组中出现次数超过一半的数字**

## 描述

给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。

数据范围：n \le 50000*n*≤50000，数组中元素的值 0 \le val \le 100000≤*v**a**l*≤10000

要求：空间复杂度：O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

### 输入描述：

保证数组输入非空，且保证有解

## 示例1

输入：

```
[1,2,3,2,2,2,5,4,2]
```

返回值：

```
2
```

```java
import java.util.*;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        // 哈希表统计每个数字出现的次数
        HashMap<Integer, Integer> mp = new HashMap<Integer, Integer>();
        // 遍历数组
        for(int i = 0; i < array.length; i++) {
            // 统计频率
            if(!mp.containsKey(array[i])) {
                mp.put(array[i], 1);
            } else {
                mp.put(array[i], mp.get(array[i]) + 1);
            }
            if(mp.get(array[i]) > array.length / 2) {
                return array[i];
            }
        }
        return 0;
    }
}
```

# **BM52** **数组中只出现一次的两个数字**

## 描述

一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

数据范围：数组长度 2\le n \le 10002≤*n*≤1000，数组中每个数的大小 0 < val \le 10000000<*v**a**l*≤1000000
要求：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

提示：输出时按非降序排列。

## 示例1

输入：

```
[1,4,1,6]
```

复制

返回值：

```
[4,6]
```

说明：

```
返回的结果中较小的数排在前面  
```

```java
import java.util.*;

public class Solution {
    public int[] FindNumsAppearOnce (int[] array) {
        HashMap<Integer, Integer> mp = new HashMap<Integer, Integer>();
        ArrayList<Integer> res = new ArrayList<Integer>();
        // 遍历数组
        for(int i = 0; i < array.length; i++) {
            // 统计每个数出现的频率
            if(!mp.containsKey(array[i])) {
                mp.put(array[i], 1);
            } else {
                mp.put(array[i], mp.get(array[i]) + 1);
            }
        }
        // 再次遍历数组
        for(int i = 0; i < array.length; i++) {
            // 找到频率为1的两个数
            if(mp.get(array[i]) == 1) {
                res.add(array[i]);
            }
        }
        // 整理次序
        if(res.get(0) < res.get(1)) {
            return new int[] {res.get(0), res.get(1)};
        } else {
            return new int[] {res.get(1), res.get(0)};
        }
    }
}
```

# **BM54** **三数之和**

## 描述

给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。

数据范围：0 \le n \le 30000≤*n*≤3000，数组中各个元素值满足 |val | \le 100∣*v**a**l*∣≤100

空间复杂度：O(n^2)*O*(*n*2)，时间复杂度 O(n^2)*O*(*n*2)

注意：

1. 三元组（a、b、c）中的元素可以按任意顺序排列。
2. 解集中不能包含重复的三元组。

## 示例1

输入：

```
[-10,0,10,20,-10,-40]
```

返回值：

```
[[-10,-10,20],[-10,0,10]]
```

```java
import java.util.*;
public class Solution {
    public ArrayList<ArrayList<Integer>> threeSum(int[] num) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        int len = num.length;
        Arrays.sort(num);
        // 去重map
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < len; i++) {
            map.put(num[i], i);
        }
        int L, M, R;
        for(int i = 0; i < len; i = map.get(L) + 1) {
            // 指定L的值
            L = num[i];
            for(int j = i + 1; j < len; j = map.get(M) + 1) {
                M = num[j];
                R = - L - M;
                if(R < M) {
                    break;
                }
                if(map.get(R) != null && map.get(R) > j) {
                    // 创建一个数组，并将满足条件的三元素放进去
                    ArrayList<Integer> list = new ArrayList<Integer>();
                    list.add(L);
                    list.add(M);
                    list.add(R);
                    res.add(list);
                }
            }
        }
        return res;
    }
}
```

# **BM55** **没有重复项数字的全排列**

## 描述

给出一组数字，返回该组数字的所有排列

例如：

[1,2,3]的所有排列如下
[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2], [3,2,1].
（以数字在数组中的位置靠前为优先级，按字典序排列输出。）

数据范围：数字个数 0 < n \le 60<*n*≤6

要求：空间复杂度 O(n!)*O*(*n*!) ，时间复杂度 O(n!）*O*(*n*!）

## 示例1

输入：

```
[1,2,3]
```

返回值：

```
[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

```java
import java.util.*;

public class Solution {
    // 交换位置函数
    private void swap(ArrayList<Integer> num, int i1, int i2) {
        int temp = num.get(i1);
        num.set(i1, num.get(i2));
        num.set(i2, temp);
    }
    
    public void recursion(ArrayList<ArrayList<Integer>> res, ArrayList<Integer> num, int index){
        // 分枝进入结尾，找到一种排列
        if(index == num.size() - 1) {
            res.add(num);
        }
        else {
            // 遍历后续的元素
            for(int i = index; i < num.size(); i++) {
                // 交换二者
                swap(num, i, index);
                // 继续往后找
                recursion(res, num, index + 1);
                // 回溯
                swap(num, i, index);
            }
        }
    }
    
    public ArrayList<ArrayList<Integer>> permute(int[] num) {
        // 先按照字典序排序
        Arrays.sort(num);
        ArrayList<ArrayList<Integer> > res = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> nums = new ArrayList<Integer>();
        //数组转ArrayList
        for(int i = 0; i < num.length; i++) {
            nums.add(num[i]);
        }
        recursion(res, nums, 0);
        return res;
    }
}
```

# **BM63** **跳台阶**

## 描述

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

数据范围：1 \leq n \leq 401≤*n*≤40

要求：时间复杂度：O(n)*O*(*n*) ，空间复杂度： O(1)*O*(1)

## 示例1

输入：

```
2
```

返回值：

```
2
```

说明：

```
青蛙要跳上两级台阶有两种跳法，分别是：先跳一级，再跳一级或者直接跳两级。因此答案为2   
```

```java
// public class Solution {
//     public int jumpFloor(int target) {
//         if(target <= 1) {
//             return 1;
//         }
//         return jumpFloor(target - 1) + jumpFloor(target - 2);
//     }
// }

// public class Solution {
//     private int[] f = new int[50];
//     public int jumpFloor(int target) {
//         if(target <= 1) {
//             return 1;
//         }
//         if(f[target] > 0) {
//             return f[target];
//         }
//         return f[target] = (jumpFloor(target - 1) + jumpFloor(target - 2));
//     }
// }
public class Solution {
    private int[] dp = new int[50];
    public int jumpFloor(int target) {
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= target; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[target];
    }
}
```

# **BM64** **最小花费爬楼梯**

## 描述

给定一个整数数组 cost \*c**o**s**t* ，其中 cost[i]\*c**o**s**t*[*i*] 是从楼梯第i \*i* 个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。



请你计算并返回达到楼梯顶部的最低花费。

数据范围：数组长度满足 1 \le n \le 10^5 \1≤*n*≤105 ，数组中的值满足 1 \le cost_i \le 10^4 \1≤*c**o**s**t**i*≤104 

## 示例1

输入：

```
[2,5,20]
```

返回值：

```
5
```

说明：

```
你将从下标为1的台阶开始，支付5 ，向上爬两个台阶，到达楼梯顶部。总花费为5   
```

```java
import java.util.*;

public class Solution {
    public int minCostClimbingStairs (int[] cost) {
        // dp[i]表示爬到第i阶楼梯需要的最小花费
        int[] dp = new int[cost.length + 1];
        for(int i = 2; i <= cost.length; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[cost.length];
    }
}
```

# **BM67** **不同路径的数目(一)**

## 描述

一个机器人在m×n大小的地图的左上角（起点）。

机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。

可以有多少种不同的路径从起点走到终点？

![img](https://uploadfiles.nowcoder.com/images/20201210/999991351_1607596327517/873CB1F2327F70DA0CA0FDC797F894A7)

备注：m和n小于等于100,并保证计算结果在int范围内

数据范围：0 < n,m \le 1000<*n*,*m*≤100，保证计算结果在32位整型范围内

要求：空间复杂度 O(nm)*O*(*n**m*)，时间复杂度 O(nm)*O*(*n**m*)

进阶：空间复杂度 O(1)*O*(1)，时间复杂度 O(min(n,m))*O*(*m**i**n*(*n*,*m*))

## 示例1

输入：

```
2,1
```

返回值：

```
1
```

```java
import java.util.*;

public class Solution {
    public int uniquePaths (int m, int n) {
        if(m == 1 || n == 1) {
            return 1;
        }
        return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);
    }
}
```

# **BM78** **打家劫舍(一)**

## 描述

你是一个经验丰富的小偷，准备偷沿街的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家；如果偷了第二家，那么就不能偷第一家和第三家。

给定一个整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。

数据范围：数组长度满足 1 \le n \le 2\times 10^5\1≤*n*≤2×105 ，数组中每个值满足 1 \le num[i] \le 5000 \1≤*n**u**m*[*i*]≤5000 

## 示例1

输入：

```
[1,2,3,4]
```

返回值：

```
6
```

说明：

```
最优方案是偷第 2，4 个房间  
```

```java
import java.util.*;

public class Solution {
    public int rob (int[] nums) {
        int len = nums.length;
        // 初始化dp数组
        int[] dp = new int[len + 1];
        dp[1] = nums[0];
        for(int i = 2; i <= len; i++) {
            // 不偷或者偷
            dp[i] = Math.max(dp[i - 1], nums[i - 1] + dp[i - 2]);
        }
        return dp[len];
    }
}
```

# **BM79** **打家劫舍(二)**

## 描述

你是一个经验丰富的小偷，准备偷沿湖的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家，如果偷了第二家，那么就不能偷第一家和第三家。沿湖的房间组成一个闭合的圆形，即第一个房间和最后一个房间视为相邻。

给定一个长度为n的整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。

数据范围：数组长度满足 1 \le n \le 2\times10^5 \1≤*n*≤2×105 ，数组中每个值满足 1 \le nums[i] \le 5000 \1≤*n**u**m**s*[*i*]≤5000 

## 示例1

输入：

```
[1,2,3,4]
```

返回值：

```
6
```

说明：

```
最优方案是偷第 2 4 个房间   
```

```java
import java.util.*;

public class Solution {
    public int rob (int[] nums) {
        int len = nums.length;
        // dp[i]表示长度为i的数组，最多能偷多少钱
        int[] dp = new int[len + 1];
        // 选择偷第一家
        dp[1] = nums[0];
        // 最后一家不能偷
        for(int i = 2; i < len; i++) {
            dp[i] = Math.max(dp[i - 1], nums[i - 1] + dp[i - 2]);
        }
        int res = dp[len - 1];
        Arrays.fill(dp, 0);
        // 不偷第一家
        dp[1] = 0;
        for(int i = 2; i <= len; i++) {
            dp[i] = Math.max(dp[i - 1], nums[i - 1] + dp[i - 2]);
        }
        return Math.max(dp[len], res);
    }
}
```

# **BM80** **买卖股票的最好时机(一)**

## 描述

假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益

1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天

2.如果不能获取到任何利润，请返回0

3.假设买入卖出均无手续费

数据范围： 0 \le n \le 10^5 , 0 \le val \le 10^40≤*n*≤105,0≤*v**a**l*≤104

要求：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
[8,9,2,5,4,7,1]
```

返回值：

```
5
```

说明：

```
在第3天(股票价格 = 2)的时候买入，在第6天(股票价格 = 7)的时候卖出，最大利润 = 7-2 = 5 ，不能选择在第2天买入，第3天卖出，这样就亏损7了；同时，你也不能在买入前卖出股票。  
```

```java
import java.util.*;

public class Solution {
    public int maxProfit (int[] prices) {
        int len = prices.length;
        int minPrices = Integer.MAX_VALUE;
        int ans = 0;
        for(int i = 0; i < len; i++) {
            if(prices[i] < minPrices) {
                minPrices = prices[i];
            } else if(prices[i] - minPrices > ans) {
                ans = prices[i] - minPrices;
            }
        }
        return ans;
    }
}
```

# **BM81** **买卖股票的最好时机(二)**

## 描述

假设你有一个数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益

\1. 你可以多次买卖该只股票，但是再次购买前必须卖出之前的股票

\2. 如果不能获取收益，请返回0

\3. 假设买入卖出均无手续费

数据范围： 1 \le n \le 1 \times 10^51≤*n*≤1×105 ， 1 \le prices[i] \le 10^41≤*p**r**i**c**e**s*[*i*]≤104

要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

进阶：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
[8,9,2,5,4,7,1]
```

返回值：

```
7
```

说明：

```
在第1天(股票价格=8)买入，第2天(股票价格=9)卖出，获利9-8=1
在第3天(股票价格=2)买入，第4天(股票价格=5)卖出，获利5-2=3
在第5天(股票价格=4)买入，第6天(股票价格=7)卖出，获利7-4=3
总获利1+3+3=7，返回7       
```

```java
import java.util.*;

public class Solution {
    public int maxProfit (int[] prices) {
        int n = prices.length;
        // dp[i][0]表示某一天不持股到该天为止的最大收益，dp[i][1]表示某天持股，到该天为止的最大收益
        int[][] dp = new int[n][2]; 
        // 第一天不持股，总收益为0
        dp[0][0] = 0; 
        // 第一天持股，总收益为减去该天的股价
        dp[0][1] = -prices[0]; 
        // 遍历后续每天，状态转移
        for(int i = 1; i < n; i++){ 
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        // 最后一天不持股，到该天为止的最大收益
        return dp[n - 1][0]; 
    }
}
```

# **BM83** **字符串变形**

## 描述

对于一个长度为 n 字符串，我们需要对它做一些变形。

首先这个字符串中包含着一些空格，就像"Hello World"一样，然后我们要做的是把这个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。

比如"Hello World"变形后就变成了"wORLD hELLO"。

数据范围: 1\le n \le 10^61≤*n*≤106 , 字符串中包括大写英文字母、小写英文字母、空格。

进阶：空间复杂度 O(n)*O*(*n*) ， 时间复杂度 O(n)*O*(*n*)

### 输入描述：

给定一个字符串s以及它的长度n(1 ≤ n ≤ 10^6)

### 返回值描述：

请返回变形后的字符串。题目保证给定的字符串均由大小写字母和空格构成。

## 示例1

输入：

```
"This is a sample",16
```

返回值：

```
"SAMPLE A IS tHIS"
```

```java
import java.util.*;

public class Solution {
    public String trans(String s, int n) {
        if(n == 0) {
            return s;
        }
        StringBuffer res = new StringBuffer();
        for(int i = 0; i < n; i++) {
            // 大小写转换
            if(s.charAt(i) <= 'Z' && s.charAt(i) >= 'A') {
                res.append((char)(s.charAt(i) - 'A' + 'a'));
            } else if(s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {
                res.append((char)(s.charAt(i) - 'a' + 'A'));
            } else {
                res.append(s.charAt(i));
            }
        }
        res = res.reverse();
        for(int i = 0; i < n; i++) {
            int j = i;
            // 以空格为界，二次翻转
            while(j < n && res.charAt(j) != ' ') {
                j++;
            }
            String temp = res.substring(i, j);
            StringBuffer buffer = new StringBuffer(temp);
            temp = buffer.reverse().toString();
            res.replace(i, j, temp);
            i = j;
        }
        return res.toString();
    }
}
```

# **BM84** **最长公共前缀**

## 描述

给你一个大小为 n 的字符串数组 strs ，其中包含n个字符串 , 编写一个函数来查找字符串数组中的最长公共前缀，返回这个公共前缀。

数据范围： 0 \le n \le 50000≤*n*≤5000， 0 \le len(strs_i) \le 50000≤*l**e**n*(*s**t**r**s**i*)≤5000

进阶：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
["abca","abc","abca","abc","abcc"]
```

返回值：

```
"abc"
```

```java
import java.util.*;


public class Solution {
    public String longestCommonPrefix (String[] strs) {
        // 纵向扫描
        if(strs.length == 0 || strs == null) {
            return "";
        }
        int rows = strs.length;
        int cols = strs[0].length();
        // 开始扫描
        for(int i = 0; i < cols; i++) {
            char firstChar = strs[0].charAt(i);
            for(int j = 1; j < rows; j++) {
                if(strs[j].length() == i || strs[j].charAt(i) != firstChar) {
                    return strs[0].substring(0, i);
                }
            }
        }
        return strs[0];
    }
}
```

# **BM85** **验证IP地址**

## 描述

编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址

IPv4 地址由十进制数和点来表示，每个地址包含4个十进制数，其范围为 0 - 255， 用(".")分割。比如，172.16.254.1；
同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。

IPv6 地址由8组16进制的数字来表示，每组表示 16 比特。这些组数字通过 (":")分割。比如, 2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。

然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。
同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。

说明: 你可以认为给定的字符串里没有空格或者其他特殊字符。

数据范围：字符串长度满足 5 \le n \le 505≤*n*≤50

进阶：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
"172.16.254.1"
```

复制

返回值：

```
"IPv4"
```

复制

说明：

```
这是一个有效的 IPv4 地址, 所以返回 "IPv4"   
```

```java
import java.util.*;

public class Solution {
    boolean isIPv4(String IP) {
        // 字符串里面没有"."
        if(IP.indexOf('.') == -1) {
            return false;
        }
        String[] s = IP.split("\\.");
        // IPv4必为4组
        if(s.length != 4) {
            return false;
        }
        for(int i = 0; i < s.length; i++) {
            // 不可缺省，有一个分割为零，说明两个点相连
            if(s[i].length() == 0) {
                return false;
            }
            // 比较数组位数及不为零时不能有前缀零
            if(s[i].length() < 0 || s[i].length() > 3 || (s[i].charAt(0) == '0' && s[i].length() != -1)) {
                return false;
            } 
            int num = 0;
            // 遍历每个分割字符串，必须为数字
            for(int j = 0; j < s[i].length(); j++) {
                char c = s[i].charAt(j);
                if(c < '0' || c > '9') {
                    return false;
                }
                // 转化为数字比较，0-255之间
                num = num * 10 + (int)(c - '0');
                if(num < 0 || num > 255) {
                    return false;
                }
            }
        }
        return true;
    }
    
    boolean isIPv6(String IP) {
        if(IP.indexOf(':') == -1) {
            return false;
        }
        String[] s = IP.split(":", -1);
        // IPv6必为8组
        if(s.length != 8) {
            return false;
        }
        for(int i = 0; i < s.length; i++) {
            // 每个分割不能缺省，不能超过4位
            if(s[i].length() == 0 || s[i].length() > 4) {
                return false;
            }
            for(int j = 0; j < s[i].length(); j++) {
                // 不能出现a-f或A-F以外的大小写字符
                char c = s[i].charAt(j);
                boolean expr = (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
                if(!expr) {
                    return false;
                }
            }
        }
        return true;
    }
    
    public String solve (String IP) {
        if(isIPv4(IP)) {
            return "IPv4";
        }
        else if(isIPv6(IP)) {
            return "IPv6";
        }
        return "Neither";
    }
}
```

# **BM87** **合并两个有序的数组**

## 描述

给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组

数据范围： 0 \le n,m \le 1000≤*n*,*m*≤100，|A_i| <=100∣*A**i*∣<=100， |B_i| <= 100∣*B**i*∣<=100


注意：
1.保证 A 数组有足够的空间存放 B 数组的元素， A 和 B 中初始的元素数目分别为 m 和 n，A的数组空间大小为 m+n

2.不要返回合并的数组，将数组 B 的数据合并到 A 里面就好了，且后台会自动将合并后的数组 A 的内容打印出来，所以也不需要自己打印

\3. A 数组在[0,m-1]的范围也是有序的

## 示例1

输入：

```
[4,5,6],[1,2,3]
```

返回值：

```
[1,2,3,4,5,6]
```

说明：

```
A数组为[4,5,6]，B数组为[1,2,3]，后台程序会预先将A扩容为[4,5,6,0,0,0]，B还是为[1,2,3]，m=3，n=3，传入到函数merge里面，然后请同学完成merge函数，将B的数据合并A里面，最后后台程序输出A数组 
```

```java
import java.util.*;
public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        int p1 = 0, p2 = 0;
        // 新开一个M+n大小的数组
        int[] sorted = new int[m + n];
        int cur;
        // 循环选择
        while(p1 < m || p2 < n) {
            if(p1 == m) {
                cur = B[p2++];
            } else if(p2 == n) {
                cur = A[p1++];
            } else if(A[p1] < B[p2]) {
                cur = A[p1++];
            } else {
                cur = B[p2++];
            }
            sorted[p1 + p2 - 1] = cur;
        }
        for(int i = 0; i != m + n; i++) {
            A[i] = sorted[i];
        }
    }
}
```

# **BM88** **判断是否为回文字符串**

## 描述

给定一个长度为 n 的字符串，请编写一个函数判断该字符串是否回文。如果是回文请返回true，否则返回false。

字符串回文指该字符串正序与其逆序逐字符一致。

数据范围：0 < n \le 10000000<*n*≤1000000

要求：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
"absba"
```

返回值：

```
true
```

```java
import java.util.*;

public class Solution {
    public boolean judge (String str) {
        // 首指针
        int left = 0;
        // 尾指针
        int right = str.length() - 1;
        // 首尾往中间靠
        while(left < right) {
            // 比较前后是否相同
            if(str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

# **BM89** **合并区间**

## 描述

给出一组区间，请合并所有重叠的区间。

请保证合并后的区间按区间起点升序排列。

数据范围：区间组数 0 \le n \le 2 \times 10^50≤*n*≤2×105，区间内 的值都满足 0 \le val \le 2 \times 10^50≤*v**a**l*≤2×105

要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(nlogn)*O*(*n**l**o**g**n*)

进阶：空间复杂度 O(val)*O*(*v**a**l*)，时间复杂度O(val)*O*(*v**a**l*)

## 示例1

输入：

```
[[10,30],[20,60],[80,100],[150,180]]
```

复制

返回值：

```
[[10,60],[80,100],[150,180]]
```

```java
import java.util.*;
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public ArrayList<Interval> merge(ArrayList<Interval> intervals) {
        ArrayList<Interval> res = new ArrayList<>();
        // 去除特殊情况
        if(intervals.size() == 0) {
            return res;
        } 
        // 重载比较，按照区间首排序
        Collections.sort(intervals, new Comparator<Interval>(){
            public int compare(Interval o1, Interval o2) {
                if(o1.start != o2.start) {
                    return o1.start - o2.start;
                } else {
                    return o1.end - o2.end;
                }
            }
        });
        // 放入第一个区间
        res.add(intervals.get(0));
        int count = 0;
        // 遍历后续区间，查看是否与末尾有重叠
        for(int i = 1; i < intervals.size(); i++) {
            Interval o1 = intervals.get(i);
            Interval origin = res.get(count);
            if(o1.start > origin.end) {
                res.add(o1);
                count++;
            }
            else {
                res.remove(count);
                Interval s = new Interval(origin.start, o1.end);
                if(o1.end < origin.end) {
                    s.end = origin.end;
                }
                res.add(s);
            }
        }
        return res;
    }
}
```

# **BM97** **旋转数组**

## 描述

一个数组A中存有 n 个整数，在不允许使用另外数组的前提下，将每个整数循环向右移 M（ M >=0）个位置，即将A中的数据由（A0 A1 ……AN-1 ）变换为（AN-M …… AN-1 A0 A1 ……AN-M-1 ）（最后 M 个数循环移至最前面的 M 个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？

数据范围：0 < n \le 1000<*n*≤100，0 \le m \le 10000≤*m*≤1000

进阶：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

## 示例1

输入：

```
6,2,[1,2,3,4,5,6]
```

返回值：

```
[5,6,1,2,3,4]
```

```java
import java.util.*;

public class Solution {
    public int[] solve (int n, int m, int[] a) {
        // 取余，因为每次长度为n的旋转数组相当于没有变化
        m = m % n;
        // 第一次逆转全部数组元素
        reverse(a, 0, n - 1);
        // 第二次只逆转开头m个
        reverse(a, 0, m - 1);
        // 第三次只逆转结尾m个
        reverse(a, m, n - 1);
        return a;
    }
    
    // 反转函数
    public void reverse(int[] nums, int start, int end) {
        while(start < end) {
            swap(nums, start++, end--);
        }
    }
    
    // 交换函数
    public void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }
    
}
```

# **BM98** **螺旋矩阵**

## 描述

给定一个m x n大小的矩阵（m行，n列），按螺旋的顺序返回矩阵中的所有元素。

数据范围：0 \le n,m \le 100≤*n*,*m*≤10，矩阵中任意元素都满足 |val| \le 100∣*v**a**l*∣≤100

要求：空间复杂度 O(nm)*O*(*n**m*) ，时间复杂度 O(nm)*O*(*n**m*)

## 示例1

输入：

```
[[1,2,3],[4,5,6],[7,8,9]]
```

返回值：

```
[1,2,3,6,9,8,7,4,5
```

```java
import java.util.ArrayList;

public class Solution {
    public ArrayList<Integer> spiralOrder(int[][] matrix) {
        ArrayList<Integer> res = new ArrayList<>();
        // 先排除特殊情况
        if(matrix.length == 0) {
            return res;
        }
        int left = 0;
        int right = matrix[0].length - 1;
        // 上边界
        int up = 0;
        // 下边界
        int down = matrix.length - 1;
        // 直到边界重合
        while(left <= right && up <= down) {
            // 上边界的从左到右
            for(int i = left; i <= right; i++) {
                res.add(matrix[up][i]);
            }
            // 下边界向下
            up++;
            if(up > down) {
                break;
            }
            // 右边界的从上到下
            for(int i = up; i <= down; i++) {
                res.add(matrix[i][right]);
            }
            // 右边界向左
            right--;
            if(left > right) {
                break;
            }
            // 下边界的从右到左
            for(int i = right; i >= left; i--) {
                res.add(matrix[down][i]);
            }
            // 下边界向上
            down--;
            if(up > down) {
                break;
            }
            // 左边界的从下到上
            for(int i = down; i >= up; i--) {
                res.add(matrix[i][left]);
            }
            // 左边界向右
            left++;
            if(left > right) {
                break;
            }
        }
        return res;
    }
}
```

