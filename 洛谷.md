# P1093 [NOIP2007 普及组] 奖学金

![image-20220327195448290](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220327195448290.png)



```c++
#include<bits/stdc++.h>

using namespace std;

struct stu {
	// 编号 
	int num;
	// 3门课的成绩:语文、数学、英语
	int c, m, e;
	// 总成绩 
	int sum;
}student[310];

// 先按总分从高到低排序，如果两个同学总分相同，
// 再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，
// 那么规定学号小的同学 排在前面
bool cmp(stu a, stu b) {
	if(a.sum > b.sum) {
		return 1;
	}
	else if(a.sum < b.sum) {
		return 0;
	}
	else{
		if(a.c > b.c) {
			return 1;
		} 
		else if(a.c < b.c) {
			return 0;
		}
		else{
			if(a.num > b.num) {
				return 0;
			}
			else{
				return 1;
			}
		}
	}
} 

int main() {
	int n;
	cin >> n;
	for(int i = 1; i <= n; i++) {
		student[i].num = i;
		// 输入 
		cin >> student[i].c >> student[i].m >> student[i].e;
		// 计算总分
		student[i].sum =  student[i].c + student[i].m + student[i].e;
	}
	sort(student + 1, student + 1 + n, cmp);
	

	for(int i = 1; i <= 5; i++) {
		cout << student[i].num << " " << student[i].sum << endl;
	}
	
	return 0;

}
```

# P1015 [NOIP1999 普及组] 回文数

![image-20220328112020376](F:\文件\算法\洛谷\image-20220328112020376.png)

![image-20220328112034883](F:\文件\算法\洛谷\image-20220328112034883.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 105;
char sixt[20] = "0123456789ABCDEF";

int n;
string m;

// 判断回文数字 
bool hw(string a) {
	// 新建字符串s 
	string s = a;
	// 反转字符串s 
	reverse(s.begin(), s.end()); 
	// 判断a和s是否相等 
	return s == a;
}

// 高精度加法过程，推广到k进制 
string add(int k, string b) {
	string a = b;
	reverse(a.begin(), a.end());
	int numa[maxn], numb[maxn], numc[maxn];
	int len = a.length(), lenc = 1;
	string ans;
	for(int i = 0; i < len; i++) {
		// isdigit() 用来检测一个字符是否是十进制数字。
		// 若参数为阿拉伯数字0~9，则返回非0值，否则返回0。
		// 对于16进制的特判，如果是数字减去 0  
		if(isdigit(a[i])) {
			numa[len - i] = a[i] - '0';
		}else {
			// 如果不是数字减去A 再加上 10
			numa[len - i] = a[i] - 'A' + 10; 
		}
		if(isdigit(b[i])) {
			numb[len - i] = b[i] - '0';
		}else {
			numb[len - i] = b[i] - 'A' + 10; 
		}
	}
	int x = 0;
	while(lenc <= len) {
		numc[lenc] = numa[lenc] + numb[lenc] + x;
		// 把除以10修改为除以k 
		x = numc[lenc] / k;
		// 这里把对10取模修改为对k取模 
		numc[lenc] %= k;
		lenc++;
	}
	numc[lenc] = x;
	while(numc[lenc] == 0) {
		lenc--;
	} 
	for(int i = lenc; i >= 1; i--) {
		ans += sixt[numc[i]];
	}
	return ans;
}

int main() {
	cin >> n >> m;
	// 模拟过程 
	for(int i = 0; i <= 30; i++) {
		// 如果是回文数字就输出步骤数 
		if(hw(m)) {
			printf("STEP=%d",i);
			return 0;
		}
		else{
			m = add(n, m);
		}
	}
	printf("Impossible!");
	return 0;
}
```

# P1075 [NOIP2012 普及组] 质因数分解

![image-20220328164554666](F:\文件\算法\洛谷\image-20220328164554666.png)

```c++
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n;
    cin >> n;
    for (int i = 2; i <= n; i++) {
		if(n % i == 0) {
			cout << n / i;
			break;
		}
    }
    return 0;
}
```

# P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题

![image-20220329153243611](F:\文件\算法\洛谷\image-20220329153243611.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int gcd(int a, int b) {
	if(b == 0) {
		return a;
	}
	else{
		return gcd(b, a % b);
	}
}

int f2(int x, int y, int z) {
	return ((x * y) / z);
}

int main() {
	int n, m, ans = 0;
	cin >> n >> m;
	for(int i = n; i <= m; i++) {
		int j = n * m / i;
		if(gcd(i, j) == n && f2(i, j, gcd(i, j)) == m) {
			ans++;
		}
	}
	cout << ans <<endl;
	return 0;
}
```

# P1068 [NOIP2009 普及组] 分数线划定

![image-20220329191643361](F:\文件\算法\洛谷\image-20220329191643361.png)

![image-20220329191703900](F:\文件\算法\洛谷\image-20220329191703900.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 5005;

// n是参加笔试的人数，m是计划录取的志愿者人数，
// f是分数线，k是报名号，s是笔试成绩，sub是下标 
int i, n, m, f, k[maxn], s[maxn], sub[maxn];

// sort规则 
bool cmp(int a, int b) {
	// 成绩相等比报名号
	if(s[a] == s[b]) {
		return k[a] < k[b];
	}
	return s[a] > s[b];
}

int main() {
	cin >> n >> m;
	for(i = 1; i <= n; i++) {
		// 输入编号和成绩，同时初始化下标 
		cin >> k[sub[i] = i] >> s[i];
	}
	// 对下标排序 
	sort(sub + 1, sub + n + 1, cmp);
	// 算分数线 
	f = s[sub[int(m * 1.5)]];
	// 算录取人数 
	for(i = 1; s[sub[i]] >= f; i++);
	cout << f << " " << i - 1 << endl;
	for(i = 1; s[sub[i]] >= f; i++) {
		cout << k[sub[i]] << " " << s[sub[i]] << endl;
	}
	return 0;
} 
```

# P1179 [NOIP2010 普及组] 数字统计

![image-20220329192934349](F:\文件\算法\洛谷\image-20220329192934349.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int check(int x) {
	int ans = 0;
	while(x) {
		int t = x % 10;
		if(t == 2) {
			ans++;
		}
		x /= 10;
	}
	return ans;
}

int main() {
	int l, r, res = 0;
	cin >> l >> r;
	for(int i = l; i <= r; i++) {
		res += check(i);
	}
	cout << res << endl;
	return 0;
}
```

# P1035 [NOIP2002 普及组] 级数求和

![image-20220329195300549](F:\文件\算法\洛谷\image-20220329195300549.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	int k, i;
	double s = 0;
	cin >> k;
	for(i = 1;; i++) {
        // 这里需要注意，需要1.0除以i
		s += 1.0 / i;
		if(s > k){
			break;
		}
	}
	cout << i << endl;
	return 0;
}
```

# P1059 [NOIP2006 普及组] 明明的随机数

![image-20220329204112726](F:\文件\算法\洛谷\image-20220329204112726.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	set<int> st;
	int n, num = 0;
	cin >> n;
	for(int i = 0; i < n; i++) {
		int j;
		cin >> j;
		st.insert(j);
	}
	set<int>::iterator it;
	cout << st.size() << endl;
	for(it = st.begin(); it != st.end(); it++) {
		cout << *it << " ";
	}
	return 0;
}
```

# P5015 [NOIP2018 普及组] 标题统计

![image-20220329211748128](F:\文件\算法\洛谷\image-20220329211748128.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 10;

int main(){
	char s[maxn];
	gets(s);
	int n = strlen(s);
	int ans = 0;
	for(int i = 0;i < n;i++){
		if(s[i]>='A'&&s[i]<='Z')
			ans++;
			
		if(s[i]>='a'&&s[i]<='z')
			ans++;
			
		if(s[i]>='0'&&s[i]<='9')
			ans++;
	}
	printf("%d",ans);
	return 0;

}
```

# P1428 小鱼比可爱

![image-20220330135109537](F:\文件\算法\洛谷\image-20220330135109537.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 105;
int fish[maxn], res[maxn]; 

int check(int x) {
	int ans = 0;
	for(int i = 0; i < x; i++) {
		if(fish[i] < fish[x]) {
			ans++;
		}
	}
	return ans;
}

int main(){
	int n;
	cin >> n;
	for(int i = 0; i < n; i++) {
		cin >> fish[i];
	}
	res[0] = 0;
	for(int i = 1; i < n; i++) {
		res[i] = check(i);
	}
	for(int i = 0; i < n - 1; i++) {
		cout << res[i] << " ";
	}
	cout << res[n - 1] << endl;
	return 0;
}
```

# P1427 小鱼的数字游戏

![image-20220330140857054](F:\文件\算法\洛谷\image-20220330140857054.png)

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
vector<ll> v;

int main(){
	bool f = true;
	ll r;
	while(f) {
		cin >> r;
		if(r == 0) {
			f = false;
			break;
		}
		v.push_back(r);
	}
	int vlen = v.size();
	// cout << vlen << endl;
	for(int i = vlen - 1; i > 0; i--) {
		cout << v[i] << " ";
	}
	cout << v[0] << endl;
	return 0;
}
```

# P1047 [NOIP2005 普及组] 校门外的树

![image-20220330145058065](F:\文件\算法\洛谷\image-20220330145058065.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e5;
int r[maxn];
int road, m;

int main(){
	cin >> road >> m;
	for(int i = 0; i <= road; i++) {
		r[i] = 1;
	}
	int start, end;
	for(int i = 0; i < m; i++) {
		cin >> start >> end;
		for(int j = start; j <= end; j++) {
			r[j] = 0;
		}
	}
	int res = 0;
	for(int i = 0; i <= road; i++) {
		if(r[i] == 1) {
			res++;
		}
	}
	cout << res << endl; 
	return 0;
}
```

# P1255 数楼梯

![image-20220330154048689](F:\文件\算法\洛谷\image-20220330154048689.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 5e3 + 5;

// f[k][i] 是第k台阶所对应的走法数 
int n, len = 1, f[maxn][maxn];

// 高精度加分， k来存阶数 
void hp(int k) {
	for(int i = 1; i <= len; i++) {
		// 套用公式
		f[k][i] = f[k - 1][i] + f[k - 2][i]; 
	}
	
	// 进位（高精度加法）
	 for(int i = 1; i <= len; i++) {
	 	if(f[k][i] >= 10) {
	 		f[k][i + 1] += f[k][i] / 10;
	 		f[k][i] = f[k][i] % 10;
	 		
	 		if(f[k][len + 1]) {
	 			len++;
	 		}
	 	}
	 }
}

int main() {
	cin >> n;
	f[1][1] = 1;
	f[2][1] = 2;
	
	for(int i = 3; i <= n; i++) {
		hp(i);
	}
	
	for(int i = len; i >= 1; i--) {
		cout << f[n][i];
	}
	return 0;
}
```

# P5733 【深基6.例1】自动修正

![image-20220330172311861](F:\文件\算法\洛谷\image-20220330172311861.png)

```c++
#include<bits/stdc++.h>
using namespace std;

char s[105];

int main() {
	cin >> s;
	// strupr、strlwr 大小写转换
	strupr(s);
	
	cout << s << endl;
	return 0;

}
```

```c++
#include<bits/stdc++.h>
using namespace std;

char s[105];

int main() {
	cin >> s;
	int len = strlen(s);
	
	for(int i = 0; i < len; i++) {
		if(s[i] >= 'a' && s[i] <= 'z') {
			s[i] -= 32;
		}
		cout << (char)s[i];
	} 

	return 0;

}
```

# P1125 [NOIP2008 提高组] 笨小猴

![image-20220330211611387](F:\文件\算法\洛谷\image-20220330211611387.png)



```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 105;
set<int> st;

bool is_prime(unsigned int n) { 
	if (n < 2) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}

int main() {
	string str;
	
	cin >> str;
	int hash[26] = {0};
	int slen = str.size();
	for(int i = 0; i < slen; i++) {
		hash[(int)str[i] - 97]++;
	}
	
	int max = 0, min = 100;
	for(int i = 0; i < 26; i++) {
		if(max < hash[i]){
			max = hash[i];
		}
		if(min > hash[i] && hash[i] != 0) {
			min = hash[i];
		}
	}
	
	if(is_prime(max - min)) {
		cout << "Lucky Word" << endl << max-min;
	}
	else {
		cout << "No Answer" << endl << "0";
	}
	return 0;

}
```



```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 105;
set<int> st;

bool is_prime(unsigned int n) { 
	if (n < 2) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}

int main() {
	char str[maxn];
	cin >> str;
	
	int slen = strlen(str);
	for(int i = 0; i < slen; i++) {
		st.insert(str[i]);
	}
	
	if(st.size() == slen) {
		cout << "No Answer" << endl;
		cout << "0" << endl;
	}else{
		int max = 0, min = maxn;
		map<char, int> mp;
		for(int i = 0; i < slen; i++) {
			mp[str[i]]++;
		}
		int mlen = mp.size();
		for(int i = 0; i < slen; i++) {
			if(mp[str[i]] > max) {
				max = mp[str[i]];
			}
			if(mp[str[i]] < min){
				min = mp[str[i]];
			}
		}
		// cout << max - min << endl;
		if(is_prime(max - min)) {
			cout << "Lucky Word" << endl;
			cout << max - min << endl;
		}else{
			cout << "No Answer" << endl;
			cout << "0" << endl;
		}
	}
	return 0;
}
```

# P1012 [NOIP1998 提高组] 拼数

![image-20220331124235306](F:\文件\算法\洛谷\image-20220331124235306.png)

```c++
#include<bits/stdc++.h>
using namespace std;

string s[25];
int n;

bool cmp(string a, string b) {
	// 自定义排序函数，这一步非常巧妙，假设a=321，b=32；
	// a+b=32132，b+a=32321这样下面sort排下来就是32>321避免出现32132>32321的情况 
	return a+b>b+a;
}
/*如果这样写：
bool cmp（string a，string b）{
    return a>b;
    会发生321>32的情况，具体原因是字符串自己的关系运算是这样设定的 
}*/
int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> s[i];
	}
	sort(s + 1, s + n + 1, cmp);
	for(int i = 1; i <= n; i++) {
		cout << s[i]; 	
	}
	return 0;
}
```

# P1051 [NOIP2005 提高组] 谁拿了最多奖学金

![image-20220331205520109](F:\文件\算法\洛谷\image-20220331205520109.png)

![image-20220331205538123](F:\文件\算法\洛谷\image-20220331205538123.png)

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 105;

struct node{
	// 姓名
    string xm;
    // 期末平均成绩，班级评议成绩
    int qm, bj;
    // 是否是学生干部，是否是西部省份学生
    char bgb, xb;
    // 发表的论文数
    int lw;
    // 个人所获的奖金数
    int ans;
    // 序号数，因为题目要求两个人所获的奖金数相同时，输出先出现的，即序号较靠前的（较小的）
    int sum;
}a[maxn];

int n, tot = 0;

bool cmp(node x, node y){
    if(x.ans == y.ans) {
    	return x.sum < y.sum;
    }
    // 奖学金数从大到小排序，相同时按序号数从小到大排序
    else return x.ans > y.ans;
}
int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        cin >> a[i].xm >> a[i].qm >> a[i].bj >> a[i].bgb >> a[i].xb >> a[i].lw;
        
        if(a[i].qm > 80 && a[i].lw >= 1) a[i].ans += 8000;
        if(a[i].qm > 85 && a[i].bj > 80) a[i].ans += 4000;
        if(a[i].qm > 90) a[i].ans += 2000;
        if(a[i].xb == 'Y' && a[i].qm > 85) a[i].ans += 1000;
        if(a[i].bj > 80 && a[i].bgb == 'Y') a[i].ans += 850;
        a[i].sum = i;
        tot += a[i].ans;//tot为总的奖学金数
    }
    sort(a + 1, a + n + 1, cmp);
    cout << a[1].xm << endl << a[1].ans << endl << tot;
    return 0;
}
```

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 105;

int qimo[maxn], pingyi[maxn], res[maxn], lunwen[maxn];
string name[maxn];
string ganbu[maxn], xibu[maxn];
string y = "Y";

void check(int index) {
	//院士奖学金，每人8000元，期末平均成绩高于80分（>80），并且在本学期内发表1篇或1篇以上论文的学生均可获得；
	if(qimo[index] > 80 && lunwen[index] >= 1) {
		res[index] += 8000;
	}
	//五四奖学金，每人4000元，期末平均成绩高于85分（>85），并且班级评议成绩高于80分（>80）的学生均可获得；
	if(qimo[index] > 85 && pingyi[index] > 80) {
		res[index] += 4000;
	}
	//成绩优秀奖，每人2000元，期末平均成绩高于90分（>90）的学生均可获得；
	if(qimo[index] > 90) {
		res[index] += 2000;
	}
	//西部奖学金，每人1000元，期末平均成绩高于85分（>85）的西部省份学生均可获得；
	if(qimo[index] > 85 && xibu[index] == y) {
		res[index] += 1000;
	}
	//班级贡献奖，每人850元，班级评议成绩高于80分（>80）的学生干部均可获得；
	if(qimo[index] > 80 && ganbu[index] == y) {
		res[index] += 850;
	}
}

int main() {
	int n; 
	cin >> n;
	
	for(int i = 0; i < n; i++) {
		cin >> name[i] >> qimo[i] >> pingyi[i] >> ganbu[i] >> xibu[i] >> lunwen[i];
	}
	for(int i = 0; i < n; i++) {
		check(i);
	}
	int max = 0, imax, sum = 0;
	for(int i = n - 1; i >= 0; i--) {
		if(res[i] > max) {
			max = res[i];
			imax = i;
		}
		sum += res[i];
	}
	
	cout << name[imax] << endl;
	cout << res[imax] << endl;
	cout << sum << endl;
	
	return 0;

}
```

# P1019 [NOIP2000 提高组] 单词接龙

![image-20220401164324468](F:\文件\算法\洛谷\image-20220401164324468.png)

```c++
#include<bits/stdc++.h>
using namespace std;

string str[20];
int use[20], length = 0, n;

int canlink(string str1, string str2) {
	// 重叠长度从1开始，直到最短的字符串长度-1 
	int minl = min(str1.length(), str2.length());
	
	for(int i = 1; i < minl; i++) {
		int flag = 1;
		for(int j = 0; j < i; j++) {
			// 逐个检查是否相等
			if(str1[str1.length() - i + j] != str2[j]) {
				flag = 0;
			} 
		}
		if(flag) {
			return i;
		}
	}
	// 无重叠部分，返回0 
	return 0;
}

void solve(string strnow, int lengthnow) {
	// 更新最大长度 
	length = max(lengthnow, length);
	for(int i = 0; i < n; i++) {
		// 该字符串使用次数需要小于2 
		if(use[i] >= 2) {
			continue; 
		}
		// 获取重叠长度 
		int c = canlink(strnow, str[i]);
		// 有重叠长度就开始DFS 
		if(c > 0) {
			use[i]++;
			solve(str[i], lengthnow + str[i].length() - c);
			use[i]--; 
		}
	}
}

int main() {
	cin >> n;
	for(int i = 0; i <= n; i++) {
		use[i] = 0;
		cin >> str[i];
	}
	// 为了指定第一个字符
	solve(' ' + str[n], 1);
	cout << length;
	
	return 0;
}
```

# P1062 [NOIP2006 普及组] 数列

![image-20220401171530586](F:\文件\算法\洛谷\image-20220401171530586.png)

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
ll k, n, ans;
stack<int> S;

int main() {
	cin >> k >> n;
	while(n) {
		// n为奇数时，对应的二进制数最低位一定为1，n&1的结果就是1，n为偶数时，是0 
		S.push(n & 1);
		// 将n右移一位之后再赋值给n
		n >>= 1;
	}
	
	while(!S.empty()) {
		ans += S.top() * pow(k, S.size() - 1);
		S.pop();
	}
	
	cout << ans << endl;
	
	return 0;
}
```

# P1097 [NOIP2007 提高组] 统计数字

![image-20220401173351554](F:\文件\算法\洛谷\image-20220401173351554.png)

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll maxn = 300000;
set<ll> st;

map<ll, ll> mp;

int main() {
	int n;
	cin >> n;
	ll num;
	for(int i = 0; i < n; i++) {
		cin >> num;
		st.insert(num);
		mp[num]++;
	}
	int mlen = mp.size();
	set<ll>::iterator it;
	int j = 0;
	for(it = st.begin(); it != st.end(); it++) {
		cout << *it << " " << mp[*it] << endl;
	}
	return 0;
}
```

# P1980 [NOIP2013 普及组] 计数问题

![image-20220401222445208](F:\文件\算法\洛谷\image-20220401222445208.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int res = 0, x;

int check(int n) {
	int ans = 0;
	while(n) {
		int t = n % 10;
		if(t == x) {
			ans++;
		}
		n /= 10;
	}
	return ans;
}

int main() {
	int n;
	cin >> n >> x;
	for(int i = 1; i <= n; i++) {
		res += check(i);
	}
	cout << res << endl;
	return 0;
}
```

# P3156 【深基15.例1】询问学号

![image-20220402105532403](F:\文件\算法\洛谷\image-20220402105532403.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 2e5 + 5;
int n, m, stu[maxn], ord;

int main() {
	scanf("%d%d",&n, &m);
	for(int i = 1; i <= n; i++) {
		scanf("%d",&stu[i]);
	}
	for(int i = 1; i <= m; i++) {
		scanf("%d",&ord);
		// binary_search(stu, stu + n, value) 只能查找元素值value所在位置 
		printf("%d\n",stu[ord]);
	}
	return 0;
}
```

# P3613 【深基15.例2】寄包柜

![image-20220402154721642](F:\文件\算法\洛谷\image-20220402154721642.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e6 + 5;
struct node {
	// s用来记录desk[i]的元素个数，表示第i个柜子已存s次物品 
	int s = 0;
	// num表示第i个柜子的第num个格子存入一个物品
	// w表示该格子存入的物品 
	vector<int> num, w;
} desk[maxn];

int main() {
	int n, q;
	scanf("%d%d",&n,&q);
	while(q--) {
		int x, a, b, c;
		scanf("%d",&x);
		if(x == 1) {
			scanf("%d%d%d",&a,&b,&c);
			// 第a个柜子存入物品 
			desk[a].s++;
			// 第b个格子中 
			desk[a].num.push_back(b);
			// 存入物品c
			desk[a].w.push_back(c); 
		}
		else {
			scanf("%d%d",&a,&b);
			// 从后往前，因为格子存放有更新
			for(int i = desk[a].s - 1; i >= 0; i--) {
				// 如果查询到该柜子的格子 
				if(desk[a].num[i] == b) {
					printf("%d\n",desk[a].w[i]);
					break;
				}
			}
		}
	}
	return 0;
}
```

# P1082 [NOIP2012 提高组] 同余方程

![image-20220402221219463](F:\文件\算法\洛谷\image-20220402221219463.png)

```c++
#include<iostream>
#include<cstdio>
using namespace std;

int a, b, x, y, k;
void exgcd(int a, int b) {
    if(b == 0) {
        x = 1;
        y = 0;
        return;
    }
    exgcd(b, a % b);
    k = x;
    x = y;
    y = k - a / b * y;
    return;
}
int main() {
    ios::sync_with_stdio(false);
    cin >> a >> b;
    exgcd(a, b);
    cout << (x + b) % b;
}
```

# P5743 【深基7.习8】猴子吃桃

![image-20220402223109184](F:\文件\算法\洛谷\image-20220402223109184.png)

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, i = 1;
    cin >> n;
    while(n != 1) {
    	i = (i + 1) * 2;
    	n--;
    }
    cout << i << endl;
}
```

# P5737 【深基7.例3】闰年展示

![image-20220403094411914](F:\文件\算法\洛谷\image-20220403094411914.png)

```c++
#include <bits/stdc++.h>
using namespace std;

int res[2000], j = 0;

int check(int n) {
	if((n % 100 != 0 && n % 4 == 0) || n % 400 == 0) {
		res[j++] = n;
		return 1;
	} 
	return 0;
}

int main() {
    int r, l, ans = 0;
    cin >> r >> l;
    for(int i = r; i <= l; i++) {
    	ans += check(i);
    }
    cout << ans << endl;
    
    for(int i = 0; i < j; i++) {
    	cout << res[i] << " ";
    }
    return 0;
}
```

# P5736 【深基7.例2】质数筛

![image-20220403095633775](F:\文件\算法\洛谷\image-20220403095633775.png)

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5 + 5;
int res[maxn], q[maxn], n, j = 0;

bool check(int x) {
	if(x < 2) {
		return false;
	}
	for(int i = 2; i * i <= x; i++) {
		if(x % i == 0) {
			return false;
		}
	}
	return true;
}

int main() {
    scanf("%d",&n);
    for(int i = 0; i < n; i++) {
    	scanf("%d",&q[i]);
    }
    for(int i = 0; i < n; i++) {
    	if(check(q[i])) {
    		res[j++] = q[i];
    	}
    }
    for(int i = 0; i < j; i++) {
    	printf("%d ",res[i]);
    }
    return 0;
}
```

# P5739 【深基7.例7】计算阶乘

![image-20220403100436482](F:\文件\算法\洛谷\image-20220403100436482.png)

```c++
#include <bits/stdc++.h>
using namespace std;

int n;

int f(int x) {
	if(x == 1 || x == 0) {
		return 1;
	} else {
		return f(x - 1) * x;
	}
}

int main() {
    scanf("%d",&n);
    cout << f(n) << endl;
    return 0;
}
```

# P5738 【深基7.例4】歌唱比赛

![image-20220403105454261](F:\文件\算法\洛谷\image-20220403105454261.png)

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 105;
const int maxm = 30;
int score[maxn][maxm];
double ave[maxn];

int main() {
    int n, m;
    scanf("%d%d",&n,&m);
    for(int i = 0; i < n; i++) {
    	for(int j = 0; j < m; j++) {
    		scanf("%d",&score[i][j]);
    	}
    }
    for(int i = 0; i < n; i++) {
    	sort(score[i], score[i] + m);
    }
    double t;
    for(int i = 0; i < n; i++) {
    	t = 0;
    	for(int j = 1; j < m - 1; j++) {
    		t += score[i][j];
    	}
    	ave[i] = t / (m - 2);
    	// printf("%d\n",ave[i]);
    }
    sort(ave, ave + n);
    printf("%.2f\n",ave[n - 1]);
    return 0;
}
```

# P5740 【深基7.例9】最厉害的学生

![image-20220403140647836](F:\文件\算法\洛谷\image-20220403140647836.png)

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e3 + 5;

struct student{
	// 姓名
	char name[20];
	// 成绩 语数英
	int c, m, e, id;
	// 总成绩
	int sum; 
} stu[maxn];

bool cmp(student x, student y) {
	// 如果总分相同返回 ID靠前的
	if(x.sum == y.sum) {
		return x.id < y.id;
	} 
	// 返回总分更大的 
	return x.sum > y.sum;
}

int main() {
	int n;
    scanf("%d",&n);
    for(int i = 0; i < n; i++) {
    	scanf("%s%d%d%d",&stu[i].name,&stu[i].c,&stu[i].m,&stu[i].e);
    	stu[i].sum = stu[i].c + stu[i].m + stu[i].e;
    	// cout << stu[i].sum << endl;
    	stu[i].id = i; 
    }
    sort(stu, stu + n, cmp);
    cout << stu[0].name << " "<< stu[0].c << " " <<stu[0].m << " " << stu[0].e << endl;
    return 0;
}
```

# P2670 [NOIP2015 普及组] 扫雷游戏

![image-20220403151347397](F:\文件\算法\洛谷\image-20220403151347397.png)

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 105;
int n, m;
char maze[maxn][maxn], res[maxn][maxn];

char check(int i, int j) {
	if(maze[i][j] == '*') {
		return '*';
	}
	char ans = '0';
	for(int a = i - 1; a <= i + 1; a++) {
		for(int b = j - 1; b <= j + 1; b++) {
			if(a == i && b == j) {
				continue;
			}
			if(maze[a][b] == '*') {
				ans++;
			}
		}
	}
	return ans;
}

int main() {
	scanf("%d%d",&n,&m);
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			cin >> maze[i][j];
		}
	}
	
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			res[i][j] = check(i, j);
		}
	}
	
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			cout << res[i][j];
		}
		cout << endl;
	}
	
	return 0;
}
```

# P2249 【深基13.例1】查找

![image-20220403164227108](F:\文件\算法\洛谷\image-20220403164227108.png)

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e7;
int a[maxn], n, m;

int main() {
	cin >> n >> m;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	int x;
	for(int i = 0; i < m; i++) {
		scanf("%d",&x);
        // lower_bound() 函数用于在指定区域内查找不小于目标值的第一个元素
        // upper_bound() 函数用于在指定范围内查找大于目标值的第一个元素
		int ans = lower_bound(a + 1, a + n + 1, x) - a;
		if(a[ans] == x){
			cout << ans << " ";
		}
		else {
			cout << "-1" << " ";
		}
	}
	return 0;
}
```

# P1551 亲戚

![image-20220403172355293](F:\文件\算法\洛谷\image-20220403172355293.png)

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5;
int n, m, q, f[maxn], c, d, a, b;

// 找出x家的大佬，也就是二叉树的祖先结点
int fd(int x) {
	if(f[x] == x) {
		return x;
	}
	else {
		// x不是他自己的爸爸，所以他的上面还有爸爸
		// 我们的目标是祖先结点，所以要问他的爸爸的爸爸是谁
		// 因此在使用一次fd(find)函数，也就是递归
		return f[x] = fd(f[x]); 
	}
} 

void hb(int x, int y) {
	// 合并x子集和y子集，直接把x子集的祖先结点
	// 与y子集的祖先结点连接起来，通俗来说就是把x
	// 的最大祖先变成y子集最大祖先的爸爸
	f[fd(y)] = fd(x);
	return; 
}

int main() {
	scanf("%d%d%d",&n,&m,&q);
	// 初始化 
	for(int i = 1; i <= n; i++) {
		f[i] = i;
	}
	for(int i = 1; i <= m; i++) {
		scanf("%d%d",&c,&d);
		hb(c, d);
	}
	for(int i = 1; i <= q; i++) {
		scanf("%d%d",&a,&b);
		// 如果a所在子集的大佬和b所在子集的大佬一样，即可知a和b在同一个集合 
		if(fd(a) == fd(b)) {
			printf("Yes\n");
		} 
		else {
			printf("No\n");
		}
	}
    return 0;
}
```

# P4445 [AHOI2018初中组]报名签到

![image-20220403175030398](F:\文件\算法\洛谷\image-20220403175030398.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e6;
long long n, dis[maxn];

int main() {
	cin >> n;
	for(int i = 0; i < n; i++) {
		cin >> dis[i];
	}
	long long l = 0;
	for(int i = 0; i < n - 1; i++) {
		if(dis[i] >= dis[i + 1]) {
			l += dis[i];
		}
		else{
			l += dis[i + 1];
		}
	}
	cout << l << endl;
	return 0;
}
```

# P1010 [NOIP1998 普及组] 幂次方

![image-20220403191838233](F:\文件\算法\洛谷\image-20220403191838233.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int n;

void search(int x) {
	if(n != 0) {
		int p = 1, q = 0;
		// 每次搜索都要输出2 
		printf("2");
		while(x >= p) {
			q++;
			p *= 2;
		} 
		// 计算幂，由于这里需要多算一次，所以计数器q-1
		q--;
		if(q == 0 || q == 2) {
			printf("(%d)",q);
		} 
		// 各种括号的判断
		if(q >= 3) {
			printf("(");
			search(q);
			printf(")");
		} 
		// 上面计数器多算了一次，因此p也要多乘了一个2
		// 输入的数x为真，（最后分解完就成0了，变成假），输出"+" 
		x -= p / 2;
		if(x) {
			printf("+");
			search(x);
		}
	}
}

int main() {
	cin >> n;
	search(n);
	return 0;
}
```

# P5734 【深基6.例6】文字处理软件

![image-20220403200254919](F:\文件\算法\洛谷\image-20220403200254919.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int n, a;
string qwq;
string c1;
string b1;
int b, c, d = -1, e;

int main() {
	cin >> n;
	cin >> qwq;
	for(int i = 0; i < n; i++) {
		cin >> a;
		if(a == 1) {
			cin >> b1;
			qwq += b1;
			cout << qwq << endl;
		}
		else if(a == 2) {
			cin >> b >> c;
			c1 = qwq.substr(b, c);
			qwq = c1;
			cout << qwq;
			cout << endl;
		}
		else if(a == 3) {
			cin >> b >> b1;
			qwq.insert(b, b1);
			cout << qwq << endl;
		}
		else if(a == 4) {
			cin >> b1;
			if(qwq.find(b1) < qwq.size()){
				cout << qwq.find(b1) << endl;
			}
			else {
				cout << "-1" << endl;
			}
		}
	}
	return 0;
}
```

# P5709 【深基2.习6】Apples Prologue / 苹果和虫子

![image-20220403214157021](F:\文件\算法\洛谷\image-20220403214157021.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int m, t, s;
int main() {
	cin >> m >> t >> s;
    // 特判t=0的情况
	if(t == 0) {
		cout << 0 << endl;
		return 0;
	}
    // 如果s是t的整数倍
	if(s % t == 0) {
        cout << max(m - s / t, 0) << endl;
    }
    // 如果不是
	else {
        cout << max(m - s / t - 1, 0) << endl;
    }
	return 0;
}
```

# P5716 【深基3.例9】月份天数

![image-20220403221543833](F:\文件\算法\洛谷\image-20220403221543833.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int n, m, mon[13] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int check(int x) {
	if((x % 4 == 0 && x % 100 != 0) || x % 400 == 0 ) {
		return 1;
	}
	return 0;
}

int main() {
	cin >> n >> m;
	if(check(n)) {
		mon[2] = 29;
	} else{
		mon[2] = 28;
	}
	cout << mon[m];
	return 0;
}
```

# P5732 【深基5.习7】杨辉三角

![image-20220403223855167](F:\文件\算法\洛谷\image-20220403223855167.png)

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N = 55;
ll f[N][N];

void init() {
    for(int i = 1; i < N; i++) {
        for(int j = 1; j <= i; j++) {
            if(j == 1) {
            	//边界条件
                f[i][j] = 1;
			}    
            else {
            	//状态转移方程
                f[i][j] = f[i - 1][j - 1] + f[i - 1][j];      
			}
		}
	}
}
int main () {
    init();
    int n;
    cin >> n;
    for(int i = 1;i <= n; i++) {
    	for(int j = 1; j <= i; j++) {
    		cout << f[i][j] << ' ';
		}
		cout << '\n';
	} 
    return 0;
}
```

# P5727 【深基5.例3】冰雹猜想

![image-20220404110617130](F:\文件\算法\洛谷\image-20220404110617130.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e6;
int n, res[maxn], j = 0;

int main() {
	cin >> n;
	res[j++] = n;
	while(n != 1) {
		if(n % 2 == 1) {
			n = n * 3 + 1;
			res[j++] = n;
		} else {
			n = n / 2;
			res[j++] = n;
		}
	}
	for(int i = j - 1; i >= 0; i--) {
		cout << res[i] << " ";
	}
	return 0;
}
```

# P5728 【深基5.例5】旗鼓相当的对手

![image-20220404111845653](F:\文件\算法\洛谷\image-20220404111845653.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e4;
int res = 0;

struct node {
	int a, b, c, sum;
} stu[maxn]; 

int check(node x, node y) {
	if(abs(x.a - y.a) <= 5 && abs(x.b - y.b) <= 5 && abs(x.c - y.c) <= 5 && abs(x.sum - y.sum) <= 10) {
		return 1;
	}
	else {
		return 0;
	}
}

int main() {
	int n;
	cin >> n;
	for(int i = 0; i < n; i++) {
		cin >> stu[i].a >> stu[i].b >> stu[i].c;
		stu[i].sum = stu[i].a + stu[i].b + stu[i].c;
	}
	for(int i = 0; i < n; i++) {
		for(int j = i + 1; j < n; j++) {
			res += check(stu[i], stu[j]);
		}
	}
	cout << res << endl;
	return 0;
}
```

# P2141 [NOIP2014 普及组] 珠心算测验

![image-20220404122402008](F:\文件\算法\洛谷\image-20220404122402008.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e4;
const int maxm = 1e5 + 5;
// t是桶，t[i]表示为i的数在集合中两两相加出现了几次
// g[i]表示值为i的数是否在集合中，1为在，0为不在 
int t[maxm], g[maxm];
int n, a[maxn], ans;

int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
		g[a[i]] = 1;
	}
	for(int i = 1; i < n; i++) {
		for(int j = i + 1; j <= n; j++) {
			t[a[i] + a[j]]++;
		}
	}
	for(int i = 1; i <= maxn - 3; i++) {
		if(t[i] > 0 && g[i]) {
			ans++;
		}
	}
	cout << ans << endl;
	return 0;
}
```

# P1601 A+B Problem（高精）

![image-20220404144608763](F:\文件\算法\洛谷\image-20220404144608763.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int compare(string str1, string str2) {
	if(str1.length() > str2.length()) {
		return 1;
	}
	else if(str1.length() < str2.length()) {
		return -1;
	}
	else {
		// compare函数，相等返回0，大于返回1，小于返回-1 
		return str1.compare(str2);
	}
}

// 高精度加法
// 只能是两个正数相加
string add(string str1, string str2) {
	string str;
	int len1 = str1.length();
	int len2 = str2.length();
	// 前面补0
	if(len1 < len2) {
		for(int i = 1; i <= len2 - len1; i++) {
			str1 = "0" + str1;
		}
	} else {
		for(int i = 1; i <= len1 - len2; i++) {
			str2 = "0" + str2;
		}
	}
	len1 = str1.length();
	int cf = 0;
	int temp;
	for(int i = len1 - 1; i >= 0; i--) {
		temp = str1[i] - '0' + str2[i] - '0' + cf;
		cf = temp / 10;
		temp %= 10;
		str = char(temp + '0') + str;
	}
	if(cf != 0) {
		str = char(cf + '0') + str;
	}
	return str;
} 

int main() {
	string str1, str2;
	cin >> str1 >> str2;
	cout << add(str1, str2);
	return 0;
}
```

# P2240 【深基12.例1】部分背包问题

![image-20220404152600371](F:\文件\算法\洛谷\image-20220404152600371.png)

## 思路

**千万不要被题目给误导了，这道题是贪心。**

**所有金币都可以分开，也就是说只要按照性价比最高的取一定得到的价值最大。**

**性价比就是这堆金币的价值除以重量。**

**只需要把这n堆金币按性价比排序就行了。**

**然后依次遍历，如果背包中剩余可以拿的重量大于等于这堆金币的重量，就全拿，否则直接装满。**

**直接装满这里注意一下整型转浮点的细节就好了。**

```c++
#include<cstdio>
#include<algorithm>
using namespace std;

// 金币结构体 
struct node {
	// w表示重量，v表示价值
	int w, v; 
} a[110];

// 快读 
int read() {
	int x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9') {
		if(c == '-') {
			f = -1;
		}
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

bool cmp(node aa, node bb) {
	return aa.v * bb.w > aa.w * bb.v;
}

int main() {
	int n = read(), m = read();
	double ans = 0;
	for(int i = 1; i <= n; i++) {
		a[i].w = read(), a[i].v = read();
	}
	sort(a + 1, a + n + 1, cmp);
	for(int i = 1; i <= n; i++) {
        // 如果a[i].w小于总重m
		if(a[i].w <= m) {
			ans += a[i].v;
			m -= a[i].w;
		} else {
            // *1.0来转数据类型
			ans += a[i].v * m * 1.0 / (a[i].w * 1.0);
            // 退出循环
			break;
		}
	}
	printf("%.2lf",ans);
	return 0;
}
```

# P3371 【模板】单源最短路径（弱化版）

![image-20220404175852165](F:\文件\算法\洛谷\image-20220404175852165.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const long long inf = 2147483647;
const int maxn = 1e4 + 5;
const int maxm = 5e5 + 5;

// n表示点的个数、m有向边的个数、s出发点的编号
int n, m, s, num_edge = 0;
int dis[maxn], vis[maxn], head[maxm];

// 结构体表示邻接表 
struct Edge {
	int next, to, dis;
} edge[maxm];

// 邻接表建图 
void addedge(int from, int to, int dis) {
	// 链式存储下一条出边 
	edge[++num_edge].next = head[from];
	// 当前节点编号
	edge[num_edge].to = to;
	// 本条边的距离
	edge[num_edge].dis = dis;
	// 记录下一次的出边情况
	head[from] = num_edge; 
}

void spfa() {
  // spfa用队列，这里用了STL的标准队列
  queue<int> q; 
  for(int i = 1; i <= n; i++) {
  	// 带权图初始化
    dis[i] = inf;
	// 记录点i是否在队列中，同dijkstra算法中的visited数组 
    vis[i] = 0; 
  }
  // 第一个顶点入队，进行标记
  q.push(s); dis[s]=0; vis[s]=1; 
  while(!q.empty()) {
  	// 取出队首
    int u = q.front(); 
    // 出队标记
    q.pop(); 
	vis[u] = 0; 
    // 邻接表遍历
    for(int i = head[u]; i; i = edge[i].next) {
      int v = edge[i].to; 
      // 如果有最短路就更改
      if(dis[v] > dis[u] + edge[i].dis) {
        dis[v] = dis[u] + edge[i].dis;
        // 未入队则入队
        if(vis[v]==0) {	
          // 标记入队
          vis[v] = 1; 
          q.push(v);
        }
      }
    }
  }
}

int main() {
	cin >> n >> m >> s;
	for(int i = 1; i <= m; i++) {
		int f, g, w;
		cin >> f >> g >> w;
		// 建图，有向图连一次边就可以了
		addedge(f, g, w); 
	}
	spfa();
	for(int i = 1; i <= n; i++) {
		// 如果是回到自己，直接输出0
		if(s == i) {
			cout << 0 << " "; 
		} else {  // 否则打印出最短距离 
			cout << dis[i] << " ";
		}
	}
	return 0;
}
```

# P1827 [USACO3.4] 美国血统 American Heritage

- **前序遍历：根左右**
- **中序遍历：左根右**
- **后序遍历：左右根**

![image-20220404192753584](F:\文件\算法\洛谷\image-20220404192753584.png)

```c++
#include<bits/stdc++.h>
using namespace std;

string pre, inor;

void work(string pre, string inor) {
	// 如果序列空了，就没有必要继续了 
	if(pre.empty()) {
		return;
	}
	// 取到前序序列的首字母，即根节点
	char root = pre[0];
	// 找到中序序列中的根节点的位置 k一般是中序遍历的中间位置
	int k = inor.find(root); 
	// 删去前序序列的根节点
	pre.erase(pre.begin());
	// 从0开始切割k个
	string leftpre = pre.substr(0, k);
	// 从k开始切割到最后
	string rightpre = pre.substr(k);
	// 从0开始切割到k个
	string leftinor = inor.substr(0, k);
	// 从k+1开始切割到最后
	string rightinor = inor.substr(k + 1);
	// 先遍历左子树，后遍历右子树，再根节点 
	work(leftpre, leftinor);
	work(rightpre, rightinor);
	printf("%c",root);
}

int main() {
	cin >> inor >> pre;
	work(pre, inor);
	putchar('\n');
	return 0;
}
```

# P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles

![image-20220404195301860](F:\文件\算法\洛谷\image-20220404195301860.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int n;
int a[1005][1005];

int main() {
	cin >> n;
	for(int i = 0; i < n; i++) {
		for(int j = 0; j <= i; j++) {
			cin >> a[i][j];
		}
	}
	for(int i = n - 2; i >= 0; i--) {
		for(int j = 0; j <= i; j++) {
            // 转移方程：a[i][j] = max(a[i + 1][j], a[i + 1][j + 1]) + a[i][j]
			a[i][j] += max(a[i + 1][j], a[i + 1][j + 1]);
		}
	}
	cout << a[0][0] << endl;
	return 0;
}
```

# P1055 [NOIP2008 普及组] ISBN 号码

![image-20220405100701560](F:\文件\算法\洛谷\image-20220405100701560.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	// 先将mod11后的11个字符存入数组 
	char a[14], mod[12] = "0123456789X";
	// 输入字符串 
	cin >> a;
	int i, j = 1, t = 0;
	for(i = 0; i < 12; i++) {
		if(a[i] == '-') {
			continue;
		}
		t += (a[i] - '0') * j++;
	} 
	if(mod[t % 11] == a[12]) {
		printf("Right");
	} else {
		a[12] = mod[t % 11];
		cout << a << endl;
	}
	return 0;
}
```

# P1424 小鱼的航程(改进版)

![image-20220405102532831](F:\文件\算法\洛谷\image-20220405102532831.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	int x, n, ans = 0;
	cin >> x >> n;
	for(int i = 1; i <= n; i++, x++) {
		if(x == 8) {
			x = 1;
		}
		if(x == 7 || x == 6) {
			continue;
		}
		else {
			ans += 250;
		}
	}
	cout << ans << endl;
	return 0;
}
```

# P1363 幻象迷宫

![image-20220405112450551](F:\文件\算法\洛谷\image-20220405112450551.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 1500 + 5;
const int dx[4] = {1, -1, 0, 0};
const int dy[4] = {0, 0, 1, -1};

int n, m;
int st_x, st_y;
int vis[MAXN][MAXN][3];
bool f1, a[MAXN][MAXN];
char ch;

void dfs(int x, int y, int lx, int ly) {
	if(f1) {
		return;
	}
	if(vis[x][y][0] && (vis[x][y][1] != lx || vis[x][y][2] != ly)) {
		f1 = 1;
		return;
	}
	vis[x][y][1] = lx, vis[x][y][2] = ly, vis[x][y][0] = 1;
	for(int i = 0; i < 4; i++) {
		int xx = (x + dx[i] + n) % n, yy = (y + dy[i] + m) % m;
		int lxx = lx + dx[i], lyy = ly + dy[i];
		if(!a[xx][yy]) {
			if(vis[xx][yy][1] != lxx || vis[xx][yy][2] != lyy || !vis[xx][yy][0]) {
				dfs(xx, yy, lxx, lyy);
			}
		}
	}
}

int main() {
	while(cin >> n >> m) {
		f1 = 0;
		memset(a, 0, sizeof(a));
		memset(vis, 0, sizeof(vis));
		for(int i = 0; i < n; i++) {
			for(int j = 0; j < m; j++) {
				cin >> ch;
				if(ch == '#') {
					a[i][j] = 1;
				}
				if(ch == 'S') {
					st_x = i;
					st_y = j;
				}
			}
		}
		dfs(st_x, st_y, st_x, st_y);
		if(f1) {
			cout << "Yes" << endl;
		} else {
			cout << "No" << endl;
		}
	}
	return 0;
}
```

# P1308 [NOIP2011 普及组] 统计单词数

![image-20220405155703151](F:\文件\算法\洛谷\image-20220405155703151.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	string a;
	string b;
	// string库，调用getline，直接读入一整行 
	getline(cin, a);
	getline(cin, b);
	int alen = a.length();
	int blen = b.length();
	// 转换大小写
	for(int i = 0; i < alen; i++) {
		a[i] = tolower(a[i]);
	} 
	for(int i = 0; i < blen; i++) {
		b[i] = tolower(b[i]);
	}
	// 连起来不算，所以要在前后加几个空格，一定是同样多的
	a = ' ' + a + ' ';
	b = ' ' + b + ' ';
	// 先看看会不会找不到
	if(b.find(a) == string::npos) {
		cout << -1 << endl;
	} 
	else { // 如果找到 
		int alpha = b.find(a);
		// 计数器初始化为0 
		int beta = b.find(a), s = 0; 
		while(beta != string::npos) {
			// 计数器 
			s++;
			beta = b.find(a, beta + 1);
		}
		cout << s << " " << alpha << endl;
	}
	return 0;
}
```

# P1597 语句解析

![image-20220405162449837](F:\文件\算法\洛谷\image-20220405162449837.png)

```c++
#include<cstdio>
using namespace std;
int a[3];
char s1, s2;
int main() {
    while (scanf("%c:=%c;",&s1,&s2)==2)//充分利用c++语言优势
     a[s1-'a']=s2 >= '0' && s2 <= '9' ? s2-'0' : a[s2-'a']; //赋值语句简洁明了
    printf("%d %d %d",a[0],a[1],a[2]);
}
```

# P5719 【深基4.例3】分类平均

![image-20220406093401993](F:\文件\算法\洛谷\image-20220406093401993.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 10005;
int n, k;
int y[maxn], a = 0, no[maxn], b = 0;;
double y_sum, n_sum;

int main() {
	cin >> n >> k;
	for(int i = 1; i <= n; i++) {
		if(i % k == 0) {
			y[a++] = i;
		} else {
			no[b++] = i;
		}
	}
	for(int i = 0; i < a; i++) {
		y_sum += y[i];
	}
	y_sum = y_sum / a;
	for(int i = 0; i < b; i++) {
		n_sum += no[i];
	}
	n_sum = n_sum / b;
	printf("%.1f %.1f",y_sum,n_sum);
	return 0;
}
```

# P5723 【深基4.例13】质数口袋

![image-20220406100011964](F:\文件\算法\洛谷\image-20220406100011964.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e5 + 5;
int res[maxn];

bool is_prime(int x) {
	if(x < 2) {
		return false;
	}
	for(int i = 2; i * i <= x; i++) {
		if(x % i == 0) {
			return false;
		} 
	}
	return true;
}

int main() {
	int L;
	cin >> L;
	int n = 2, j = 0;
	while(L) {
		if(is_prime(n) && L - n >= 0) {
			res[j++] = n;
			L -= n;
			n++;
		} 
		else if(is_prime(n) && L - n < 0) {
			break;
		}
		else {
			n++;
		}
	}
	for(int i = 0; i < j; i++) {
		cout << res[i] << endl;
	}
	cout << j << endl;
	return 0;
}
```

# P1403 [AHOI2005]约数研究

![image-20220406105039322](F:\文件\算法\洛谷\image-20220406105039322.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int n, ans;

int main() {
    scanf("%d",&n);
    for(int i = 1, j; i <= n; i = j + 1) {
        j = n / (n / i);
        ans += (n / i) * (j - i + 1);
    }
    printf("%d",ans);
	return 0;
}
```

# P5731 【深基5.习6】蛇形方阵

![image-20220406141656001](F:\文件\算法\洛谷\image-20220406141656001.png)

```c++
#include<bits/stdc++.h>
using namespace std;
// 快读 
int read() {
	int x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9') {
		if(c == '-') {
			f = -1;
		}
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}
// 记录输出数组 
int a[15][15];
// 改变位置得数组  0表示右，1表示下，2表示左，3表示上
int pos[4][2] = {0,1, 1,0, 0,-1, -1,0}; 
int main() {
    int n = read(), x = 1, y = 1, d = 0;
    for(int i = 1; i <= n * n; i++) {
    	a[x][y] = i;
    	int tx = x + pos[d][0];
    	int ty = y + pos[d][1];
    	// 改变方向  a[tx][ty]表示已经访问过 
    	if(tx < 1 || tx > n || ty < 1 || ty > n || a[tx][ty]) {
    		d = (d + 1) % 4;
    	}
    	x += pos[d][0];
    	y += pos[d][1];
    }
    for(int i = 1; i <= n; i++) {
    	for(int j = 1; j <= n; j++) {
    		printf("%3d",a[i][j]);
    	}
    	if(i < n) {
    		printf("\n");
    	}
    }
	return 0;
}
```

# P1554 梦中的统计

![image-20220406143034178](F:\文件\算法\洛谷\image-20220406143034178.png)

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
map<ll, ll> mp;

void check(int x) {
	while(x) {
		int t = x % 10;
		mp[t]++;
		x /= 10;
	}
} 

int main() {
    int m, n;
    cin >> m >> n;
    for(int i = m; i <= n; i++) {
    	check(i);
    }
    for(int i = 0; i < 10; i++) {
    	cout << mp[i] << " ";
    }
	return 0;
}
```

# P1434 [SHOI2002]滑雪

![image-20220406161539776](F:\文件\算法\洛谷\image-20220406161539776.png)

```c++
#include<bits/stdc++.h>
using namespace std;
// 存点 
struct node {
	int i, j, num, f;
};
struct cmp1{
	bool operator()(node x, node y) {
		return x.num > y.num;
	}
};
// 优先队列小的在前面 
priority_queue<node, vector<node>, cmp1> q;
int n, m, maxn, maxj, maxi, w, top = 0, g[105][105], f[105][105];
int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
    	for(int j = 1; j <= m; j++) {
    		f[i][j] = 1;
    		cin >> g[i][j];
    		node a;
    		a.i = i;
    		a.j = j;
    		a.f = 0; 
    		a.num = g[i][j];
    		q.push(a);
    	}
    }
    while(!q.empty()) {
    	node now1 = q.top();
    	// 坐标 
    	int i = now1.i;
    	int j = now1.j;
    	// 权值 
    	int now = now1.num;
    	q.pop();
    	// dp
    	if(g[i - 1][j] < now) {
    		f[i][j] = max(f[i][j], f[i - 1][j] + 1);
    	}
    	if(g[i + 1][j] < now) {
    		f[i][j] = max(f[i][j], f[i + 1][j] + 1);
    	}
    	if(g[i][j - 1] < now) {
    		f[i][j] = max(f[i][j], f[i][j - 1] + 1);
    	}
    	if(g[i][j + 1] < now) {
    		f[i][j] = max(f[i][j], f[i][j + 1] + 1);
    	}
    	if(maxn < f[i][j]) {
    		maxn = f[i][j];
    	}
    }
    cout << maxn;
	return 0;
}
```

# P2347 [NOIP1996 提高组] 砝码称重

![image-20220406164706384](F:\文件\算法\洛谷\image-20220406164706384.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e7 + 5;
int f[maxn];
int c[maxn];

int main() {
    int n = 0;
    // 砝码大小预处理 
    int num[10] = {0,1,2,3,5,10,20};
    for(int i = 1; i <= 6; i++) {
    	int k;
    	cin >> k;
    	for(int j = 1; j <= k; j++) {
    		c[++n] = num[i];
    	}
    }
    f[0] = 1;
    int sum = 0, ans = 0;
    for(int i = 1; i <= n; i++) {
    	sum += c[i];
    }
    for(int i = 1; i <= n; i++) {
        // 满足：j >= c[i]
    	for(int j = sum; j >= c[i]; j--) {
            // 转移方程
    		f[j] = f[j - c[i]];
    	}
    }
    for(int i = 1; i <= sum; i++) {
    	if(f[i]) {
    		ans++;
    	}
    }
    cout << "Total=" << ans;
	return 0;
}
```

# P1048 [NOIP2005 普及组] 采药

![image-20220406181540985](F:\文件\算法\洛谷\image-20220406181540985.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int w[105], val[105];
int dp[1005];

int main() {
    int t, m, res = 1;
    cin >> t >> m;
    for(int i = 1; i <= m; i++) {
    	cin >> w[i] >> val[i]; 
    }
    for(int i = 1; i <= m; i++) {
    	for(int j = t; j >= 0; j--) {
    		if(j >= w[i]) {
    			dp[j] = max(dp[j - w[i]] + val[i], dp[j]);
    		}
    	}
    }
    cout << dp[t] << endl;
    return 0;
}
```

# P1020 [NOIP1999 普及组] 导弹拦截

![image-20220406182535520](F:\文件\算法\洛谷\image-20220406182535520.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 100010;
int a[N], d1[N], d2[N], n;
int main() {
	while (cin >> a[++n]); n--;		//输入
	int len1 = 1, len2 = 1;		//初始长度为1
	d1[1] = a[1];		//用于求不上升序列长度
	d2[1] = a[1];		//用于求上升序列长度
	for (int i = 2; i <= n; i++) {		//从a[2]开始枚举每个数(a[1]已经加进去了)
		if (d1[len1] >= a[i]) d1[++len1] = a[i];		//如果满足要求(不上升)就加入d1
		else {		//否则用a[i]替换d1中的一个数
			int p1 = upper_bound(d1 + 1, d1 + 1 + len1, a[i], greater<int>()) - d1;
			d1[p1] = a[i]; 
		}
		if (d2[len2] < a[i]) d2[++len2] = a[i];		//同上
		else {
			int p2 = lower_bound(d2 + 1, d2 + 1 + len2, a[i]) - d2;
			d2[p2] = a[i];
		}
	}
	cout << len1 << endl << len2;		//输出
	return 0;		//结束
}
```

# P1765 手机

![image-20220406195029073](F:\文件\算法\洛谷\image-20220406195029073.png)

```c++
#include<bits/stdc++.h>
using namespace std;

map<char, int> mp;

int main() {
	mp['a'] = 1, mp['b'] = 2, mp['c'] = 3;
	mp['d'] = 1, mp['e'] = 2, mp['f'] = 3;
	mp['g'] = 1, mp['h'] = 2, mp['i'] = 3;
	mp['j'] = 1, mp['k'] = 2, mp['l'] = 3;
	mp['m'] = 1, mp['n'] = 2, mp['o'] = 3;
	mp['p'] = 1, mp['q'] = 2, mp['r'] = 3, mp['s'] = 4;
	mp['t'] = 1, mp['u'] = 2, mp['v'] = 3;
	mp['w'] = 1, mp['x'] = 2, mp['y'] = 3, mp['z'] = 4;
	mp[' '] = 1;
	string str;
	getline(cin, str);
	int len = str.length();
	int res = 0;
	for(int i = 0; i < len; i++) {
		res += mp[str[i]];
	}
	cout << res;
	return 0;
}
```

# P2415 集合求和

![image-20220406201225065](F:\文件\算法\洛谷\image-20220406201225065.png)

![image-20220406201336538](F:\文件\算法\洛谷\image-20220406201336538.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int a[35], i = 0, j;
long long s = 0;

int main() {
	while(cin >> a[i++]);
	for(j = 0; j < i; j++) {
		s += a[j];
	}
	s *= pow(2, i - 2);
	cout << s;
	return 0;
}
```

# P1226 【模板】快速幂||取余运算

![image-20220407074719765](F:\文件\算法\洛谷\image-20220407074719765.png)

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
ll B, P, K;

ll qpow(int base, int p) {
	if(p == 1) {
		return base;
	}
	else if(p == 0) {
		return 1;
	}
	else {
		ll ans = qpow(base, p / 2) % K;
		ll ans1 = (ans % K * ans % K) % K;
		if(p % 2 == 1) {
			ans1 = (ans1 % K * base % K) % K;
		}
		ans1 = ans1 % K;
		return ans1;
	}
}

int main() {
	cin >> B >> P >> K;
	ll ans = qpow(B, P);
	ans = ans % K;
	printf("%lld^%lld mod %lld=%lld",B,P,K,ans);
	return 0;
}
```

# P1629 邮递员送信

![image-20220407093334267](F:\文件\算法\洛谷\image-20220407093334267.png)

```c++
#include<bits/stdc++.h>
using namespace std;

// 邻接矩阵：a[1005][1005]
int a[1005][1005], d[1005], i, j;
const int INF = 1e9;

// 邻接矩阵初始化 
void chushi(int n) {
	for(i = 1; i <= n; i++) {
		for(j = 1; j <= n; j++) {
			if(i != j) {
				// 求最短路径要初始化为无限大 
				a[i][j] = INF;
			}
		}
	}
}

// 单源最短路径 
void dij(int n) {
	bool f[1005] = {0};
	f[1] = 1;
	int v;
	for(i = 1; i < n; i++) {
		int min = INF;
		for(j = 1; j <= n; j++) {
			// 找未标记中最小的
			if(!f[j] && min > d[j]) {
				min = d[j];
				v = j;
			} 
		}
		// 标记 
		f[v] = 1;
		for(j = 1; j <= n; j++) {
			if(!f[j] && a[v][j] + d[v] < d[j]) {
				d[j] = a[v][j] + d[v];
			}
		}
	}
} 

// 翻转
void over(int n) {
	for(int i = 1; i <= n; i++) {
		for(int j = i + 1; j <= n; j++) {
			int t = 0;
			t = a[i][j];
			a[i][j] = a[j][i];
			a[j][i] = t;
		}
	}
} 

int main() {
	int n, m, x, y, z;
	cin >> n >> m;
	chushi(n);
	for(i = 1; i <= m; i++) {
		cin >> x >> y >> z;
		// 防止同一条路多次输入
		a[x][y] = min(a[x][y], z); 
	}
	for(i = 1; i <= n; i++) {
		// 路径长度初始化
		d[i] = a[1][i]; 
	}
	dij(n);
	int ans = 0;
	for(i = 1; i <= n; i++) {
		ans += d[i];
	}
	over(n);
	for(i = 1; i <= n; i++) {
		d[i] = a[1][i];
	}
	dij(n);
	for(i = 1; i <= n; i++) {
		ans += d[i];
	}
	cout << ans << endl;
	return 0;
}
```

# P4779 【模板】单源最短路径（标准版）

![image-20220407102639271](F:\文件\算法\洛谷\image-20220407102639271.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 100010, maxm = 500010, inf = 1e9;

struct edge{
	int to, dis, next;
};

edge e[maxm];
int head[maxn], dis[maxn], cnt;
bool vis[maxn];
int n, m, s;

inline void add_edge(int u, int v, int d) {
	cnt++;
	e[cnt].dis = d;
	e[cnt].to = v;
	e[cnt].next = head[u];
	head[u] = cnt;
}

struct node{
	int dis;
	int pos;
	bool operator <(const node &x)const {
		return x.dis < dis;
	}
};

std::priority_queue<node> q;
inline void dijkstra() {
	dis[s] = 0;
	q.push((node){0, s});
	while(!q.empty()) {
		node tmp = q.top();
		q.pop();
		int x = tmp.pos, d = tmp.dis;
		if(vis[x]) {
			continue;
		}
		vis[x] = 1;
		for(int i = head[x]; i; i = e[i].next) {
			int y = e[i].to;
			if(dis[y] > dis[x] + e[i].dis) {
				dis[y] = dis[x] + e[i].dis;
				if(!vis[y]) {
					q.push((node){dis[y], y});
				}
			}
		}
	}
}

int main() {
	scanf("%d%d%d",&n, &m, &s);
	for(int i = 1; i <= n; i++) {
		dis[i] = inf;
	}
	for(int i = 0; i < m; i++) {
		int u, v, d;
		scanf("%d%d%d",&u,&v,&d);
		add_edge(u, v, d);
	}
	dijkstra();
	for(int i = 1; i <= n; i++) {
		printf("%d ", dis[i]);
	}
	return 0;
}
```

# P1706 全排列问题

![image-20220407144144328](F:\文件\算法\洛谷\image-20220407144144328.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int a[10];

int main() {
	int n, i, j = 1, k;
	cin >> n;
	for(i = 1; i <= n; i++) {
		// a[1-n] = n-1
		a[i] = n - i + 1;
		// 计算n! 
		j *= i;
	} 
	for(i = 1; i <= j; i++) {
		next_permutation(a + 1, a + n + 1);
		for(k = 1; k <= n; k++) {
			cout << "    " << a[k];
		}
		cout << endl;
	} 
	return 0;
}
```

# P1036 [NOIP2002 普及组] 选数

![image-20220407150141479](F:\文件\算法\洛谷\image-20220407150141479.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int n, k;
int a[25];
long long ans;

bool is_prime(int x) {
	if(x < 2) {
		return false;
	}
	for(int i = 2; i * i <= x; i++) {
		if(x % i == 0) {
			return false;
		}
	}
	return true;
}

void dfs(int m, int sum, int startx) {
	if(m == k) {
		if(is_prime(sum)) {
			ans++;
		}
		return;
	}
	for(int i = startx; i < n; i++) {
		dfs(m + 1, sum + a[i], i + 1);
	}
	return;
}

int main() {
	scanf("%d%d",&n,&k);
	for(int i = 0; i < n; i++) {
		scanf("%d",&a[i]);
	}
	dfs(0, 0, 0);
	printf("%d\n",ans);
	return 0;
}
```

# P1009 [NOIP1998 普及组] 阶乘之和

![image-20220407152333407](F:\文件\算法\洛谷\image-20220407152333407.png)

```c++
#include<bits/stdc++.h>
using namespace std;

int n, a[105] = {0}, s[105] = {0};

// 高精乘法 
void change(int x) {
	int g = 0;
	for(int i = 100; i >= 0; i--) {
		a[i] = a[i] * x + g;
		g = a[i] / 10;
		a[i] = a[i] % 10;
	}
}

// 高精加法
void qh() {
	int g = 0;
	for(int i = 100; i >= 0; i--) {
		s[i] = s[i] + a[i] + g;
		g = s[i] / 10;
		s[i] = s[i] % 10;
	}
} 

void sc() {
	int w;
	for(int i = 0; i <= 100; i++) {
		if(s[i] != 0) {
			w = i;
			break;
		}
	}
	for(int i = w; i <= 100; i++) {
		printf("%d",s[i]);
	}
}

int main() {
	scanf("%d",&n);
	s[100] = a[100] = 1;
	for(int i = 2; i <= n; i++) {
		change(i);
		qh();
	}
	sc();
	return 0;
}
```

# P1598 垂直柱状图

![image-20220407200210205](F:\文件\算法\洛谷\image-20220407200210205.png)

```c++
#include<bits/stdc++.h>
using namespace std;

// 定义计数数组
int ff[26];

int main() {
	int i, j, n, maxn = 0;
	char a[81];
	for(i = 0; i < 4; i++) {
		gets(a);
		n = strlen(a);
		for(j = 0; j < n; j++) {
			if(a[j] >= 'A' && a[j] <= 'Z') {
				ff[a[j] - 'A']++;
			}
		}
	}
	for(i = 0; i < 26; i++) {
		maxn = max(maxn, ff[i]);
	}
	for(i = maxn; i > 0; i--) {
		for(j = 0; j < 26; j++) {
			if(ff[j] >= i) {
				printf("* ");
			} else {
				printf("  ");
			}
		}
		printf("\n");
	}
	for(i = 0; i < 26; i++) {
		printf("%c ",i + 'A');
	}
	return 0;
}
```

